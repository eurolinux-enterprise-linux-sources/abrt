From c96426ba817e9f915367e6848ccd6a69b4a3ed57 Mon Sep 17 00:00:00 2001
From: Jakub Filak <jfilak@redhat.com>
Date: Mon, 20 Apr 2015 07:56:34 +0200
Subject: [ABRT PATCH] make the dump directories owned by root by default

It was discovered that the abrt event scripts create a user-readable
copy of a sosreport file in abrt problem directories, and include
excerpts of /var/log/messages selected by the user-controlled process
name, leading to an information disclosure.

This issue was discovered by Florian Weimer of Red Hat Product Security.

Related: #1212868

Signed-off-by: Jakub Filak <jfilak@redhat.com>

Conflicts:
	src/daemon/abrt.conf
	src/include/libabrt.h
	src/lib/abrt_conf.c
---
 src/daemon/abrt-server.c     | 2 +-
 src/daemon/abrt.conf         | 9 +++++++++
 src/hooks/abrt-hook-ccpp.c   | 9 ++++++---
 src/include/libabrt.h        | 2 ++
 src/lib/abrt_conf.c          | 8 ++++++++
 src/plugins/abrt-dump-oops.c | 8 ++++++++
 6 files changed, 34 insertions(+), 4 deletions(-)

diff --git a/src/daemon/abrt-server.c b/src/daemon/abrt-server.c
index 602a41a..ff0fa06 100644
--- a/src/daemon/abrt-server.c
+++ b/src/daemon/abrt-server.c
@@ -108,7 +108,7 @@ static int create_debug_dump()
     /* No need to check the path length, as all variables used are limited, and dd_create()
        fails if the path is too long. */
 
-    struct dump_dir *dd = dd_create(path, client_uid, 0640);
+    struct dump_dir *dd = dd_create(path, g_settings_privatereports ? 0 : client_uid, 0640);
     if (!dd)
     {
         error_msg_and_die("Error creating crash dump %s", path);
diff --git a/src/daemon/abrt.conf b/src/daemon/abrt.conf
index c7ad417..b7e149a 100644
--- a/src/daemon/abrt.conf
+++ b/src/daemon/abrt.conf
@@ -20,3 +20,12 @@ MaxCrashReportsSize = 1000
 # selinux policy.
 #
 DeleteUploaded = no
+
+# Disable this option if you want to allow regular users to have file system
+# rights to read the problem data stored in DumpLocation.
+#
+# Caution:
+# THE PROBLEM DATA CONTAINS EXCERPTS OF /var/log/messages, dmesg AND sosreport
+# data GENERATED BY abrtd UNDER THE USER root.
+#
+PrivateReports = yes
diff --git a/src/hooks/abrt-hook-ccpp.c b/src/hooks/abrt-hook-ccpp.c
index ebb462b..f378236 100644
--- a/src/hooks/abrt-hook-ccpp.c
+++ b/src/hooks/abrt-hook-ccpp.c
@@ -691,6 +691,9 @@ int main(int argc, char** argv)
         }
     }
 
+    /* If PrivateReports is on, root owns all problem directories */
+    const uid_t dduid = g_settings_privatereports ? 0 : fsuid;
+
     /* Open a fd to compat coredump, if requested and is possible */
     if (setting_MakeCompatCore && ulimit_c != 0)
         /* note: checks "user_pwd == NULL" inside; updates core_basename */
@@ -789,19 +792,19 @@ int main(int argc, char** argv)
         return 1;
     }
 
-
-    /* use fsuid instead of uid, so we don't expose any sensitive
+    /* use dduid (either fsuid or 0) instead of uid, so we don't expose any
      * information of suided app in /var/spool/abrt
      *
      * dd_create_skeleton() creates a new directory and leaves ownership to
      * the current user, hence, we have to call dd_reset_ownership() after the
      * directory is populated.
      */
-    dd = dd_create_skeleton(path, fsuid, 0640, /*no flags*/0);
+    dd = dd_create_skeleton(path, dduid, 0640, /*no flags*/0);
     if (dd)
     {
         char *rootdir = get_rootdir(pid);
 
+        /* This function uses fsuid only for its value. The function stores fsuid in a file name 'uid'*/
         dd_create_basic_files(dd, fsuid, NULL);
 
         char source_filename[sizeof("/proc/%lu/somewhat_long_name") + sizeof(long)*3];
diff --git a/src/include/libabrt.h b/src/include/libabrt.h
index ebd1b6e..63fe0e8 100644
--- a/src/include/libabrt.h
+++ b/src/include/libabrt.h
@@ -55,6 +55,8 @@ extern char *        g_settings_sWatchCrashdumpArchiveDir;
 extern char *        g_settings_dump_location;
 #define g_settings_delete_uploaded abrt_g_settings_delete_uploaded
 extern bool          g_settings_delete_uploaded;
+#define g_settings_privatereports abrt_g_settings_privatereports
+extern bool          g_settings_privatereports;
 
 
 #define load_abrt_conf abrt_load_abrt_conf
diff --git a/src/lib/abrt_conf.c b/src/lib/abrt_conf.c
index 0b53c21..d79d36d 100644
--- a/src/lib/abrt_conf.c
+++ b/src/lib/abrt_conf.c
@@ -22,6 +22,7 @@ char *        g_settings_sWatchCrashdumpArchiveDir = NULL;
 unsigned int  g_settings_nMaxCrashReportsSize = 1000;
 char *        g_settings_dump_location = NULL;
 bool          g_settings_delete_uploaded = 0;
+bool          g_settings_privatereports = true;
 
 void free_abrt_conf_data()
 {
@@ -72,6 +73,13 @@ static void ParseCommon(map_string_h *settings, const char *conf_filename)
         g_hash_table_remove(settings, "DeleteUploaded");
     }
 
+    value = g_hash_table_lookup(settings, "PrivateReports");
+    if (value)
+    {
+        g_settings_privatereports = string_to_bool(value);
+        g_hash_table_remove(settings, "PrivateReports");
+    }
+
     GHashTableIter iter;
     char *name;
     /*char *value; - already declared */
diff --git a/src/plugins/abrt-dump-oops.c b/src/plugins/abrt-dump-oops.c
index 0dbe7fe..43a145b 100644
--- a/src/plugins/abrt-dump-oops.c
+++ b/src/plugins/abrt-dump-oops.c
@@ -139,6 +139,14 @@ static unsigned save_oops_to_dump_dir(GList *oops_list, unsigned oops_cnt)
         mode = 0640;
         my_euid = geteuid();
     }
+    if (g_settings_privatereports)
+    {
+        if (world_readable_dump)
+            log("Not going to make dump directories world readable because PrivateReports is on");
+
+        mode = 0640;
+        my_euid = 0;
+    }
 
     pid_t my_pid = getpid();
     unsigned errors = 0;
-- 
1.8.3.1

