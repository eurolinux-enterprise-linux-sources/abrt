From a9f7fc21d4894141d702f12d737427f7eb54042c Mon Sep 17 00:00:00 2001
From: Jakub Filak <jfilak@redhat.com>
Date: Wed, 6 May 2015 15:58:59 +0200
Subject: [ABRT PATCH] lib: avoid race conditions while going trough all dump
 directories

Florian Weimer <fweimer@redhat.com>

    dump_dir_accessible_by_uid() is fundamentally insecure because it
    opens up a classic time-of-check-time-of-use race between this
    function and and dd_opendir().

Related: #1214745

Signed-off-by: Jakub Filak <jfilak@redhat.com>
---
 src/lib/problem_api.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/src/lib/problem_api.c b/src/lib/problem_api.c
index d940767..d184457 100644
--- a/src/lib/problem_api.c
+++ b/src/lib/problem_api.c
@@ -70,6 +70,15 @@ static GList* scan_directory(const char *path,
             continue; /* skip "." and ".." */
 
         char *full_name = concat_path_file(path, dent->d_name);
+
+        int dir_fd = dd_openfd(full_name);
+        if (dir_fd < 0)
+        {
+            VERB2 perror_msg("can't open problem directory '%s'", full_name);
+            free(full_name);
+            continue;
+        }
+
         if (dump_dir_accessible_by_uid(full_name, caller_uid))
         {
             /* Silently ignore *any* errors, not only EACCES.
@@ -78,7 +87,7 @@ static GList* scan_directory(const char *path,
              */
             int sv_logmode = logmode;
             logmode = 0;
-            struct dump_dir *dd = dd_opendir(full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK);
+            struct dump_dir *dd = dd_fdopendir(dir_fd, full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK);
             logmode = sv_logmode;
             /* or we could just setuid?
              - but it would require locking, because we want to setuid back before we server another request..
@@ -93,6 +102,9 @@ static GList* scan_directory(const char *path,
                 dd_close(dd); //doesn't fail even if dd == NULL
             }
         }
+        else
+            close(dir_fd);
+
         free(full_name);
     }
     closedir(dp);
@@ -237,4 +249,4 @@ unsigned int get_problems_count(GList *paths, unsigned long since)
     list_free_with_free(pths);
 
     return pci.problem_count;
-}
\ No newline at end of file
+}
-- 
1.8.3.1

