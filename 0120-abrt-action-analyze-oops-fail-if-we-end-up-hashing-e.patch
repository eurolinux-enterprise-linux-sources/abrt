From 8549aa0d619d3c0e3fb30a76debbc83039acb062 Mon Sep 17 00:00:00 2001
From: Denys Vlasenko <vda.linux@googlemail.com>
Date: Thu, 13 Dec 2012 17:29:20 +0100
Subject: [ABRT EL6 PATCH 120/200] abrt-action-analyze-oops: fail if we end up
 hashing "" (empty string). Closes rhbz#862013

While we are at it, fix memory leaks (w/o changing the logic)
in oops hashing code.

This is backported commit ab2eefe80e175e0b4e04077e390d39e0297f4f68

Signed-off-by: Denys Vlasenko <vda.linux@googlemail.com>
---
 src/include/libabrt.h                  |  2 +-
 src/lib/kernel.c                       | 78 ++++++++++++++++++----------------
 src/plugins/abrt-action-analyze-oops.c | 13 ++++--
 tests/koops-parser.at                  |  4 +-
 4 files changed, 54 insertions(+), 43 deletions(-)

diff --git a/src/include/libabrt.h b/src/include/libabrt.h
index 26b8db3..317e6f4 100644
--- a/src/include/libabrt.h
+++ b/src/include/libabrt.h
@@ -73,7 +73,7 @@ char *koops_extract_version(const char *line);
 #define kernel_tainted_short abrt_kernel_tainted_short
 char *kernel_tainted_short(const char *kernel_bt);
 #define koops_hash_str abrt_koops_hash_str
-void koops_hash_str(char hash_str[SHA1_RESULT_LEN*2 + 1], char *oops_buf, const char *oops_ptr);
+int koops_hash_str(char hash_str[SHA1_RESULT_LEN*2 + 1], const char *oops_buf);
 #define koops_extract_oopses abrt_koops_extract_oopses
 void koops_extract_oopses(GList **oops_list, char *buffer, size_t buflen);
 
diff --git a/src/lib/kernel.c b/src/lib/kernel.c
index 7ce61bb..2d22ab5 100644
--- a/src/lib/kernel.c
+++ b/src/lib/kernel.c
@@ -366,8 +366,10 @@ next_line:
     free(lines_info);
 }
 
-void koops_hash_str(char hash_str[SHA1_RESULT_LEN*2 + 1], char *oops_buf, const char *oops_ptr)
+int koops_hash_str(char hash_str[SHA1_RESULT_LEN*2 + 1], const char *oops_buf)
 {
+    struct strbuf *kernel_bt = strbuf_new();
+
     // Example of call trace part of oops:
     // Call Trace:
     // [<f88e11c7>] ? radeon_cp_resume+0x7d/0xbc [radeon]
@@ -380,52 +382,48 @@ void koops_hash_str(char hash_str[SHA1_RESULT_LEN*2 + 1], char *oops_buf, const
     // [<c0403c76>] ? syscall_call+0x7/0xb
     // Code:...  <======== we should ignore everything which isn't call trace
     // RIP  ...
-    struct strbuf *kernel_bt = strbuf_new();
-    char *call_trace = strstr(oops_buf, "Call Trace");
+    char *call_trace = strcasestr(oops_buf, "Call Trace:"); /* yes, it must be case-insensitive */
     if (call_trace)
     {
-        call_trace += sizeof("Call Trace\n");
-        char *end_line = strchr(call_trace, '\n');
+        /* Different architectures have different case
+         * and different kind/amount of whitespace after ":" -
+         * don't assume there is a single "\n"!
+         */
+        call_trace += sizeof("Call Trace:")-1;
+        call_trace = skip_whitespace(call_trace);
         int i = 0;
-        while (end_line && end_line[0] != '\0')
+        for (;;)
         {
+            char *end_line = strchr(call_trace, '\n');
+            if (!end_line)
+                break;
             char *line = xstrndup(call_trace, end_line - call_trace);
 
             char *p = skip_whitespace(line);
             char *end_mem_block = strchr(p, ' ');
             if (!end_mem_block)
-                break; /* no memblock, we are done */
+                goto done; /* no memblock, we are done */
             if (p[0] != '[' || p[1] != '<' || end_mem_block[-2] != '>' || end_mem_block[-1] != ']')
-                break; /* no memblock, we are done */
+                goto done; /* no memblock, we are done */
 
+            /* skip symbols prefixed with "?" */
             end_mem_block = skip_whitespace(end_mem_block);
-
-            char *begin_off_len, *function;
-
-            /* skip symbols prefixed with ? */
             if (end_mem_block && *end_mem_block == '?')
-            {
-                free(line);
                 goto skip_line;
-            }
-            /* strip out offset +off/len */
-            begin_off_len = strchr(end_mem_block, '+');
-            if (!begin_off_len)
-                error_msg_and_die("'%s'\nno +offset/len at the end of bt", end_mem_block);
-
-            function = xstrndup(end_mem_block, begin_off_len - end_mem_block);
-            strbuf_append_strf(kernel_bt, "%s\n", function);
-            free(line);
-            free(function);
+            /* strip out "+off/len" */
+            p = strchrnul(end_mem_block, '+');
+            /* append "func_name\n" */
+            strbuf_append_strf(kernel_bt, "%.*s\n", (int)(p - end_mem_block), end_mem_block);
             if (i == 5)
+            {
+ done:
+                free(line);
                 break;
-
+            }
             ++i;
-        skip_line:
-            call_trace += end_line - call_trace + 1;
-            end_line = strchr(call_trace, '\n');
-            if (end_line)
-                ++end_line; /* skip \n */
+ skip_line:
+            free(line);
+            call_trace = end_line + 1;
         }
         goto gen_hash;
     }
@@ -434,20 +432,26 @@ void koops_hash_str(char hash_str[SHA1_RESULT_LEN*2 + 1], char *oops_buf, const
      * WARNING: at net/wireless/core.c:614 wdev_cleanup_work+0xe9/0x120 [cfg80211]() (Not tainted)
      * then hash only "file:line func+ofs/len" part.
      */
-    if (strncmp(oops_ptr, "WARNING: at ", sizeof("WARNING: at ")-1) == 0)
+    if (strncmp(oops_buf, "WARNING: at ", sizeof("WARNING: at ")-1) == 0)
     {
-        const char *p = oops_ptr + sizeof("WARNING: at ")-1;
+        const char *p = oops_buf + sizeof("WARNING: at ")-1;
         p = strchr(p, ' '); /* skip filename:NNN */
         if (p)
         {
             p = strchrnul(p + 1, ' '); /* skip function_name+0xNN/0xNNN */
-            oops_ptr += sizeof("WARNING: at ")-1;
-            while (oops_ptr < p)
-                strbuf_append_char(kernel_bt, *oops_ptr++);
+            oops_buf += sizeof("WARNING: at ")-1;
+            while (oops_buf < p)
+                strbuf_append_char(kernel_bt, *oops_buf++);
         }
     }
 
-gen_hash: ;
+ gen_hash: ;
+    VERB3 log("bt to hash: '%s'", kernel_bt->buf);
+
+    /* If we failed to find and process bt, we may end up hashing "".
+     * Not good. Let user know it via return value.
+     */
+    int bad = (kernel_bt->len == 0);
 
     char hash_bytes[SHA1_RESULT_LEN];
     sha1_ctx_t sha1ctx;
@@ -458,6 +462,8 @@ gen_hash: ;
 
     bin2hex(hash_str, hash_bytes, SHA1_RESULT_LEN)[0] = '\0';
     VERB3 log("hash: %s", hash_str);
+
+    return bad;
 }
 
 char *koops_extract_version(const char *linepointer)
diff --git a/src/plugins/abrt-action-analyze-oops.c b/src/plugins/abrt-action-analyze-oops.c
index 3eb0a61..a936ea3 100644
--- a/src/plugins/abrt-action-analyze-oops.c
+++ b/src/plugins/abrt-action-analyze-oops.c
@@ -58,13 +58,18 @@ int main(int argc, char **argv)
 
     char *oops = dd_load_text(dd, FILENAME_BACKTRACE);
     char hash_str[SHA1_RESULT_LEN*2 + 1];
-    koops_hash_str(hash_str, oops, oops);
+    int bad = koops_hash_str(hash_str, oops);
     free(oops);
 
-    dd_save_text(dd, FILENAME_UUID, hash_str);
-    dd_save_text(dd, FILENAME_DUPHASH, hash_str);
+    if (bad)
+        error_msg("Can't find a meaningful backtrace for hashing in '%s'", dump_dir_name);
+    else
+    {
+        dd_save_text(dd, FILENAME_UUID, hash_str);
+        dd_save_text(dd, FILENAME_DUPHASH, hash_str);
+    }
 
     dd_close(dd);
 
-    return 0;
+    return bad;
 }
diff --git a/tests/koops-parser.at b/tests/koops-parser.at
index 0096368..54ed028 100644
--- a/tests/koops-parser.at
+++ b/tests/koops-parser.at
@@ -120,10 +120,10 @@ int run_test(const struct test_struct *test)
 	char *oops2 = fread_full(test->expected_results);
 
 	char hash_oops1[SHA1_RESULT_LEN*2 + 1];
-	koops_hash_str(hash_oops1, oops1, oops1);
+	koops_hash_str(hash_oops1, oops1);
 
 	char hash_oops2[SHA1_RESULT_LEN*2 + 1];
-	koops_hash_str(hash_oops2, oops2, oops2);
+	koops_hash_str(hash_oops2, oops2);
 
 	if (!strcmp(hash_oops1, hash_oops2))
 		return 0;
-- 
1.8.3.1

