From 49df4a1ef399bf2b542b7c9daa66fbeb23a697a0 Mon Sep 17 00:00:00 2001
From: Jakub Filak <jfilak@redhat.com>
Date: Fri, 9 May 2014 10:42:33 +0200
Subject: [ABRT PATCH] introduce abrt-auto-reporting utility

abrt-auto-reporting simplifies enabling and disabling of the
Auto-reporting feature.

This patch also adds a text suggesting to enable the auto-reporting into
abrt-cli list's output.

Related to rhbz#1044424

Signed-off-by: Jakub Filak <jfilak@redhat.com>

Conflicts:

	configure.ac
	doc/Makefile.am
	po/POTFILES.in
	src/cli/list.c
	src/daemon/Makefile.am
---
 doc/abrt-cli.txt                 |   4 +-
 po/POTFILES.in                   |   1 +
 src/cli/list.c                   |  26 +++++--
 src/daemon/Makefile.am           |  14 +++-
 src/daemon/abrt-auto-reporting.c | 152 +++++++++++++++++++++++++++++++++++++++
 src/include/libabrt.h            |   6 ++
 src/lib/abrt_conf.c              |  16 +++++
 7 files changed, 210 insertions(+), 9 deletions(-)
 create mode 100644 src/daemon/abrt-auto-reporting.c

diff --git a/doc/abrt-cli.txt b/doc/abrt-cli.txt
index 9680ad6..3fb6696 100644
--- a/doc/abrt-cli.txt
+++ b/doc/abrt-cli.txt
@@ -23,8 +23,8 @@ OPTIONS
 -d,--detailed::
    Show detailed report
 
--f,--full::
-   List even reported problems
+-n,--not-reported::
+   List only not-reported problems
 
 AUTHORS
 -------
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 9dd904e..dc16089 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -10,6 +10,7 @@ src/daemon/abrtd.c
 src/daemon/abrt-handle-event.c
 src/gui-gtk/abrt.desktop.in
 src/gui-gtk/main.c
+src/daemon/abrt-auto-reporting.c
 src/lib/abrt_conf.c
 src/lib/hooklib.c
 src/lib/problem_api.c
diff --git a/src/cli/list.c b/src/cli/list.c
index 565b1f4..c93f69f 100644
--- a/src/cli/list.c
+++ b/src/cli/list.c
@@ -58,16 +58,17 @@ static void print_crash(problem_data_t *problem_data, int detailed)
 
 /**
  * Prints a list containing "crashes" to stdout.
- * @param include_reported
+ * @param only_unreported
  *   Do not skip entries marked as already reported.
  */
-static void print_crash_list(vector_of_problem_data_t *crash_list, int detailed, int include_reported, long since, long until)
+static bool print_crash_list(vector_of_problem_data_t *crash_list, int detailed, int only_not_reported, long since, long until)
 {
+    bool output = false;
     unsigned i;
     for (i = 0; i < crash_list->len; ++i)
     {
         problem_data_t *crash = get_problem_data(crash_list, i);
-        if (!include_reported)
+        if (only_not_reported)
         {
             if (!get_problem_item_content_or_NULL(crash, FILENAME_REPORTED_TO))
                 continue;
@@ -86,7 +87,9 @@ static void print_crash_list(vector_of_problem_data_t *crash_list, int detailed,
         print_crash(crash, detailed);
         if (i != crash_list->len - 1)
             printf("\n");
+        output = true;
     }
+    return output;
 }
 
 int cmd_list(int argc, const char **argv)
@@ -95,14 +98,14 @@ int cmd_list(int argc, const char **argv)
         "& list [options] [DIR]..."
         );
 
-    int opt_full = 0;
+    int opt_not_reported = 0;
     int opt_detailed = 0;
     int opt_since = 0;
     int opt_until = 0;
     struct options program_options[] = {
         OPT__VERBOSE(&g_verbose),
         OPT_GROUP(""),
-        OPT_BOOL('f', "full"     , &opt_full,      _("List even reported problems")),
+        OPT_BOOL('n', "not-reported"     , &opt_not_reported,      _("List only not-reported problems")),
         /* deprecate -d option with --pretty=full*/
         OPT_BOOL('d', "detailed" , &opt_detailed,  _("Show detailed report")),
         OPT_INTEGER('s', "since" , &opt_since,  _("List only the problems more recent than specified timestamp")),
@@ -123,10 +126,21 @@ int cmd_list(int argc, const char **argv)
 
     g_ptr_array_sort_with_data(ci, &cmp_problem_data, (char *) FILENAME_LAST_OCCURRENCE);
 
-    print_crash_list(ci, opt_detailed, opt_full, opt_since, opt_until);
+    const bool output = print_crash_list(ci, opt_detailed, opt_not_reported, opt_since, opt_until);
+
     free_vector_of_problem_data(ci);
     list_free_with_free(D_list);
 
+    load_abrt_conf();
+    if (!g_settings_autoreporting)
+    {
+        if (output)
+            putchar('\n');
+
+        printf(_("The Autoreporting feature is disabled. Please consider enabling it by issuing\n"
+                 "'abrt-auto-reporting enabled' as a user with root privileges\n"));
+    }
+
     return 0;
 }
 
diff --git a/src/daemon/Makefile.am b/src/daemon/Makefile.am
index 17d7b15..fb57c9c 100644
--- a/src/daemon/Makefile.am
+++ b/src/daemon/Makefile.am
@@ -12,7 +12,8 @@ bin_PROGRAMS = \
 sbin_PROGRAMS = \
     abrtd \
     abrt-server \
-    abrt-dbus
+    abrt-dbus \
+    abrt-auto-reporting
 
 libexec_PROGRAMS = abrt-handle-event
 
@@ -102,6 +103,17 @@ abrt_action_save_package_data_LDADD = \
 dbusabrtconfdir = ${sysconfdir}/dbus-1/system.d/
 dist_dbusabrtconf_DATA = dbus-abrt.conf
 
+abrt_auto_reporting_SOURCES = \
+    abrt-auto-reporting.c
+abrt_auto_reporting_CPPFLAGS = \
+    -I$(srcdir)/../include \
+    -I$(srcdir)/../lib \
+    $(LIBREPORT_CFLAGS) \
+    -D_GNU_SOURCE
+abrt_auto_reporting_LDADD = \
+    ../lib/libabrt.la \
+    $(LIBREPORT_LIBS)
+
 daemonconfdir = $(CONF_DIR)
 dist_daemonconf_DATA = \
     abrt.conf \
diff --git a/src/daemon/abrt-auto-reporting.c b/src/daemon/abrt-auto-reporting.c
new file mode 100644
index 0000000..0909bed
--- /dev/null
+++ b/src/daemon/abrt-auto-reporting.c
@@ -0,0 +1,152 @@
+/*
+    Copyright (C) 2014  RedHat inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+#include "libabrt.h"
+
+#include <stdio.h>
+
+#define CONF_NAME "abrt.conf"
+#define OPTION_NAME "AutoreportingEnabled"
+
+#define STATE_MANUAL "disabled"
+#define STATE_AUTO "enabled"
+
+const char *const REPORTING_STATES[6][2] = {
+    {STATE_MANUAL, "no" },
+    {STATE_AUTO,   "yes"},
+    {"no",         "no" },
+    {"yes",        "yes"},
+    {"0",          "no" },
+    {"1",          "yes"},
+};
+
+static int
+set_abrt_reporting(map_string_t *conf, const char *opt_value)
+{
+    const char *const def_value = REPORTING_STATES[0][1];
+    const char *const cur_value = get_map_string_item_or_NULL(conf, OPTION_NAME);
+
+    if (  (cur_value == NULL && strcmp(def_value, opt_value) != 0)
+       || (cur_value != NULL && strcmp(cur_value, opt_value) != 0))
+    {
+        replace_map_string_item(conf, xstrdup(OPTION_NAME), xstrdup(opt_value));
+        return save_abrt_conf_file(CONF_NAME, conf);
+    }
+
+    /* No changes needed -> success */
+    return 1;
+}
+
+static const char *
+get_abrt_reporting(map_string_t *conf)
+{
+    const char *const cur_value = get_map_string_item_or_empty(conf, OPTION_NAME);
+    const int index = !!string_to_bool(cur_value);
+    return REPORTING_STATES[index][0];
+}
+
+int main(int argc, char *argv[])
+{
+    setlocale(LC_ALL, "");
+    /* Hack:
+     * Right-to-left scripts don't work properly in many terminals.
+     * Hebrew speaking people say he_IL.utf8 looks so mangled
+     * they prefer en_US.utf8 instead.
+     */
+    const char *msg_locale = setlocale(LC_MESSAGES, NULL);
+    if (msg_locale && strcmp(msg_locale, "he_IL.utf8") == 0)
+        setlocale(LC_MESSAGES, "en_US.utf8");
+#if ENABLE_NLS
+    bindtextdomain(PACKAGE, LOCALEDIR);
+    textdomain(PACKAGE);
+#endif
+
+    abrt_init(argv);
+    const char *program_usage_string = _(
+            "& [ "STATE_MANUAL" | "STATE_AUTO" | yes | no | 1 | 0 ]\n"
+            "\n"
+            "Get or modify a value of the auto-reporting option. The changes will take\n"
+            "effect immediately and will be persistent.\n"
+            "\n"
+            ""STATE_MANUAL":\n"
+            "User have to report the detect problems manually\n"
+            "\n"
+            ""STATE_AUTO":\n"
+            "ABRT uploads an uReport which was generated for a detected problem\n"
+            "immediately after the detection phase. uReport generally contains a stack\n"
+            "trace which only describes the call stack of the program at the time of the\n"
+            "crash and does not contain contents of any variables.  Every uReport also\n"
+            "contains identification of the operating system, versions of the RPM packages\n"
+            "involved in the crash, and whether the program ran under a root user.\n"
+            "\n"
+            "See abrt-auto-reporting(1) for more details.\n"
+    );
+
+    /* Keep enum above and order of options below in sync! */
+    struct options program_options[] = {
+        OPT__VERBOSE(&g_verbose),
+        OPT_END()
+    };
+
+    const unsigned optind = parse_opts(argc, argv, program_options, program_usage_string);
+
+    argv += optind;
+    argc -= optind;
+
+    if (argc > 2)
+    {
+        error_msg(_("Invalid number of arguments"));
+        show_usage_and_die(program_usage_string, program_options);
+    }
+
+    int exit_code = EXIT_FAILURE;
+
+    map_string_t *conf = new_map_string();
+    if (!load_abrt_conf_file(CONF_NAME, conf))
+        goto finito;
+
+    if (argc == 2)
+    {
+        const char *const new_value = argv[1];
+        const char *opt_value = NULL;
+        for (int i = 0; i < sizeof(REPORTING_STATES)/sizeof(REPORTING_STATES[0]); ++i)
+        {
+            if (strcasecmp(new_value, REPORTING_STATES[i][0]) == 0)
+            {
+                opt_value = REPORTING_STATES[i][1];
+                break;
+            }
+        }
+
+        if (opt_value == NULL)
+        {
+            error_msg(_("Unknown option value: '%s'\n"), new_value);
+            show_usage_and_die(program_usage_string, program_options);
+        }
+
+        exit_code = set_abrt_reporting(conf, opt_value) ? EXIT_SUCCESS : EXIT_FAILURE;
+        goto finito;
+    }
+
+    printf("%s\n", get_abrt_reporting(conf));
+    exit_code = EXIT_SUCCESS;
+
+finito:
+    free_map_string(conf);
+    return exit_code;
+}
diff --git a/src/include/libabrt.h b/src/include/libabrt.h
index 3902051..7fa4e1e 100644
--- a/src/include/libabrt.h
+++ b/src/include/libabrt.h
@@ -71,6 +71,12 @@ int load_abrt_conf_file(const char *file, map_string_t *settings);
 #define load_abrt_plugin_conf_file abrt_load_abrt_plugin_conf_file
 int load_abrt_plugin_conf_file(const char *file, map_string_t *settings);
 
+#define save_abrt_conf_file abrt_save_abrt_conf_file
+int save_abrt_conf_file(const char *file, map_string_t *settings);
+
+#define save_abrt_plugin_conf_file abrt_save_abrt_plugin_conf_file
+int save_abrt_plugin_conf_file(const char *file, map_string_t *settings);
+
 
 int check_recent_crash_file(const char *filename, const char *executable);
 
diff --git a/src/lib/abrt_conf.c b/src/lib/abrt_conf.c
index cfea941..f611b0c 100644
--- a/src/lib/abrt_conf.c
+++ b/src/lib/abrt_conf.c
@@ -129,3 +129,19 @@ int load_abrt_plugin_conf_file(const char *file, map_string_t *settings)
 
     return load_conf_file_from_dirs(file, base_directories, settings, /*skip key w/o values:*/ false);
 }
+
+int save_abrt_conf_file(const char *file, map_string_t *settings)
+{
+    char *path = concat_path_file(CONF_DIR, file);
+    int retval = save_conf_file(path, settings);
+    free(path);
+    return retval;
+}
+
+int save_abrt_plugin_conf_file(const char *file, map_string_t *settings)
+{
+    char *path = concat_path_file(PLUGINS_CONF_DIR, file);
+    int retval = save_conf_file(path, settings);
+    free(path);
+    return retval;
+}
-- 
1.8.3.1

