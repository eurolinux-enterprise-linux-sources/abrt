From 10a3547879c1a4f3e0546b65725dd22d08d97050 Mon Sep 17 00:00:00 2001
From: Richard Marko <rmarko@redhat.com>
Date: Wed, 5 Dec 2012 16:15:13 +0100
Subject: [ABRT EL6 PATCH 157/197] abrt-python: initial

---
 src/python-problem/doc/api.rst                   |  15 +
 src/python-problem/doc/conf.py                   | 258 +++++++++++++++++
 src/python-problem/doc/index.rst                 |  37 +++
 src/python-problem/doc/properties.rst            |  78 +++++
 src/python-problem/doc/usage.rst                 |  41 +++
 src/python-problem/examples/daemon_example.py    |   9 +
 src/python-problem/examples/edit_example.py      |  14 +
 src/python-problem/examples/list_all_example.py  |   6 +
 src/python-problem/examples/list_example.py      |   7 +
 src/python-problem/examples/selinux_example.py   |   7 +
 src/python-problem/examples/userspace_example.py |  20 ++
 src/python-problem/problem/__init__.py           | 268 +++++++++++++++++
 src/python-problem/problem/exception.py          |  11 +
 src/python-problem/problem/proxies.py            | 126 ++++++++
 src/python-problem/problem/tools.py              |  19 ++
 src/python-problem/test                          |   2 +
 src/python-problem/tests/base.py                 |  15 +
 src/python-problem/tests/test_api.py             | 351 +++++++++++++++++++++++
 src/python-problem/tests/test_get.py             |  22 ++
 src/python-problem/tests/test_internal.py        | 120 ++++++++
 src/python-problem/tests/test_list.py            |  27 ++
 src/python-problem/tests/test_tools.py           |  30 ++
 src/python-problem/tests/util.py                 |  36 +++
 23 files changed, 1519 insertions(+)
 create mode 100644 src/python-problem/doc/api.rst
 create mode 100644 src/python-problem/doc/conf.py
 create mode 100644 src/python-problem/doc/index.rst
 create mode 100644 src/python-problem/doc/properties.rst
 create mode 100644 src/python-problem/doc/usage.rst
 create mode 100644 src/python-problem/examples/daemon_example.py
 create mode 100644 src/python-problem/examples/edit_example.py
 create mode 100644 src/python-problem/examples/list_all_example.py
 create mode 100644 src/python-problem/examples/list_example.py
 create mode 100644 src/python-problem/examples/selinux_example.py
 create mode 100644 src/python-problem/examples/userspace_example.py
 create mode 100644 src/python-problem/problem/__init__.py
 create mode 100644 src/python-problem/problem/exception.py
 create mode 100644 src/python-problem/problem/proxies.py
 create mode 100644 src/python-problem/problem/tools.py
 create mode 100755 src/python-problem/test
 create mode 100644 src/python-problem/tests/base.py
 create mode 100644 src/python-problem/tests/test_api.py
 create mode 100644 src/python-problem/tests/test_get.py
 create mode 100644 src/python-problem/tests/test_internal.py
 create mode 100644 src/python-problem/tests/test_list.py
 create mode 100644 src/python-problem/tests/test_tools.py
 create mode 100644 src/python-problem/tests/util.py

diff --git a/src/python-problem/doc/api.rst b/src/python-problem/doc/api.rst
new file mode 100644
index 0000000..2a3c8b4
--- /dev/null
+++ b/src/python-problem/doc/api.rst
@@ -0,0 +1,15 @@
+.. _api:
+
+Stable API Documentation
+========================
+
+.. automodule:: problem
+   :members: Problem, list, get
+
+Specific problem types
+----------------------
+
+.. automodule:: problem
+   :members:
+   :noindex:
+   :exclude-members: Problem, list, get
diff --git a/src/python-problem/doc/conf.py b/src/python-problem/doc/conf.py
new file mode 100644
index 0000000..27c81fd
--- /dev/null
+++ b/src/python-problem/doc/conf.py
@@ -0,0 +1,258 @@
+# -*- coding: utf-8 -*-
+#
+# python-problem documentation build configuration file, created by
+# sphinx-quickstart on Tue Dec  4 12:03:58 2012.
+#
+# This file is execfile()d with the current directory set to its containing dir.
+#
+# Note that not all possible configuration values are present in this
+# autogenerated file.
+#
+# All configuration values have a default; values that are commented out
+# serve to show the default.
+
+import sys, os
+
+# If extensions (or modules to document with autodoc) are in another directory,
+# add these directories to sys.path here. If the directory is relative to the
+# documentation root, use os.path.abspath to make it absolute, like shown here.
+sys.path.insert(0, os.path.abspath('..'))
+
+# -- General configuration -----------------------------------------------------
+
+# If your documentation needs a minimal Sphinx version, state it here.
+#needs_sphinx = '1.0'
+
+# Add any Sphinx extension module names here, as strings. They can be extensions
+# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
+extensions = ['sphinx.ext.autodoc', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = ['_templates']
+
+# The suffix of source filenames.
+source_suffix = '.rst'
+
+# The encoding of source files.
+#source_encoding = 'utf-8-sig'
+
+# The master toctree document.
+master_doc = 'index'
+
+# General information about the project.
+project = u'python-problem'
+copyright = u'2012, Richard Marko'
+
+# The version info for the project you're documenting, acts as replacement for
+# |version| and |release|, also used in various other places throughout the
+# built documents.
+#
+# The short X.Y version.
+version = '0.1'
+# The full version, including alpha/beta/rc tags.
+release = '0.1'
+
+# The language for content autogenerated by Sphinx. Refer to documentation
+# for a list of supported languages.
+#language = None
+
+# There are two options for replacing |today|: either, you set today to some
+# non-false value, then it is used:
+#today = ''
+# Else, today_fmt is used as the format for a strftime call.
+#today_fmt = '%B %d, %Y'
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+exclude_patterns = ['_build']
+
+# The reST default role (used for this markup: `text`) to use for all documents.
+#default_role = None
+
+# If true, '()' will be appended to :func: etc. cross-reference text.
+#add_function_parentheses = True
+
+# If true, the current module name will be prepended to all description
+# unit titles (such as .. function::).
+#add_module_names = True
+
+# If true, sectionauthor and moduleauthor directives will be shown in the
+# output. They are ignored by default.
+#show_authors = False
+
+# The name of the Pygments (syntax highlighting) style to use.
+pygments_style = 'sphinx'
+
+# A list of ignored prefixes for module index sorting.
+#modindex_common_prefix = []
+
+
+# -- Options for HTML output ---------------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+html_theme = 'default'
+
+# Theme options are theme-specific and customize the look and feel of a theme
+# further.  For a list of options available for each theme, see the
+# documentation.
+#html_theme_options = {}
+
+# Add any paths that contain custom themes here, relative to this directory.
+#html_theme_path = []
+
+# The name for this set of Sphinx documents.  If None, it defaults to
+# "<project> v<release> documentation".
+#html_title = None
+
+# A shorter title for the navigation bar.  Default is the same as html_title.
+#html_short_title = None
+
+# The name of an image file (relative to this directory) to place at the top
+# of the sidebar.
+#html_logo = None
+
+# The name of an image file (within the static path) to use as favicon of the
+# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
+# pixels large.
+#html_favicon = None
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+html_static_path = ['_static']
+
+# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
+# using the given strftime format.
+#html_last_updated_fmt = '%b %d, %Y'
+
+# If true, SmartyPants will be used to convert quotes and dashes to
+# typographically correct entities.
+#html_use_smartypants = True
+
+# Custom sidebar templates, maps document names to template names.
+#html_sidebars = {}
+
+# Additional templates that should be rendered to pages, maps page names to
+# template names.
+#html_additional_pages = {}
+
+# If false, no module index is generated.
+#html_domain_indices = True
+
+# If false, no index is generated.
+#html_use_index = True
+
+# If true, the index is split into individual pages for each letter.
+#html_split_index = False
+
+# If true, links to the reST sources are added to the pages.
+#html_show_sourcelink = True
+
+# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
+#html_show_sphinx = True
+
+# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
+#html_show_copyright = True
+
+# If true, an OpenSearch description file will be output, and all pages will
+# contain a <link> tag referring to it.  The value of this option must be the
+# base URL from which the finished HTML is served.
+#html_use_opensearch = ''
+
+# This is the file name suffix for HTML files (e.g. ".xhtml").
+#html_file_suffix = None
+
+# Output file base name for HTML help builder.
+htmlhelp_basename = 'python-problemdoc'
+
+
+# -- Options for LaTeX output --------------------------------------------------
+
+latex_elements = {
+# The paper size ('letterpaper' or 'a4paper').
+#'papersize': 'letterpaper',
+
+# The font size ('10pt', '11pt' or '12pt').
+#'pointsize': '10pt',
+
+# Additional stuff for the LaTeX preamble.
+#'preamble': '',
+}
+
+# Grouping the document tree into LaTeX files. List of tuples
+# (source start file, target name, title, author, documentclass [howto/manual]).
+latex_documents = [
+  ('index', 'python-problem.tex', u'python-problem Documentation',
+   u'Richard Marko', 'manual'),
+]
+
+# The name of an image file (relative to this directory) to place at the top of
+# the title page.
+#latex_logo = None
+
+# For "manual" documents, if this is true, then toplevel headings are parts,
+# not chapters.
+#latex_use_parts = False
+
+# If true, show page references after internal links.
+#latex_show_pagerefs = False
+
+# If true, show URL addresses after external links.
+#latex_show_urls = False
+
+# Documents to append as an appendix to all manuals.
+#latex_appendices = []
+
+# If false, no module index is generated.
+#latex_domain_indices = True
+
+
+# -- Options for manual page output --------------------------------------------
+
+# One entry per manual page. List of tuples
+# (source start file, name, description, authors, manual section).
+man_pages = [
+    ('index', 'python-problem', u'python-problem Documentation',
+     [u'Richard Marko'], 1)
+]
+
+# If true, show URL addresses after external links.
+#man_show_urls = False
+
+
+# -- Options for Texinfo output ------------------------------------------------
+
+# Grouping the document tree into Texinfo files. List of tuples
+# (source start file, target name, title, author,
+#  dir menu entry, description, category)
+texinfo_documents = [
+  ('index', 'python-problem', u'python-problem Documentation',
+   u'Richard Marko', 'python-problem', 'One line description of project.',
+   'Miscellaneous'),
+]
+
+# Documents to append as an appendix to all manuals.
+#texinfo_appendices = []
+
+# If false, no module index is generated.
+#texinfo_domain_indices = True
+
+# How to display URL addresses: 'footnote', 'no', or 'inline'.
+#texinfo_show_urls = 'footnote'
+
+def setup(app):
+    app.connect('autodoc-process-signature', process_signature)
+
+def process_signature(app, what, name, obj, options, signature,
+    return_annotation):
+
+    if what not in ('function'):
+        return
+
+    new_params = list()
+    for param in (x.strip() for x in signature[1:-1].split(',')):
+        if '__' not in param:
+            new_params.append(param)
+
+    return ('(%s)' % ', '.join(new_params), return_annotation)
diff --git a/src/python-problem/doc/index.rst b/src/python-problem/doc/index.rst
new file mode 100644
index 0000000..3c81b9d
--- /dev/null
+++ b/src/python-problem/doc/index.rst
@@ -0,0 +1,37 @@
+.. python-problem documentation master file, created by
+   sphinx-quickstart on Tue Dec  4 12:03:58 2012.
+   You can adapt this file completely to your liking, but it should at least
+   contain the root `toctree` directive.
+
+python-problem
+==============
+
+High-level API for querying, creating and manipulating
+problems handled by `ABRT <https://fedorahosted.org/abrt/>`_ 
+in Python.
+
+It works on top of low-level DBus or socket API provided
+by ABRT. Socket API serves only as a fallback option
+for systems without new DBus problem API
+as it can only handle the creation of new problems.
+
+This project lives in the
+`abrt repository <http://git.fedorahosted.org/git/abrt.git>`_ 
+and is distributed under GPLv2 license.
+
+Contents:
+
+.. toctree::
+   :maxdepth: 2
+
+   usage
+   api
+   properties
+
+Indices and tables
+==================
+
+* :ref:`genindex`
+* :ref:`modindex`
+* :ref:`search`
+
diff --git a/src/python-problem/doc/properties.rst b/src/python-problem/doc/properties.rst
new file mode 100644
index 0000000..e5b9452
--- /dev/null
+++ b/src/python-problem/doc/properties.rst
@@ -0,0 +1,78 @@
+.. _properties:
+
+Problem object properties
+=========================
+
+Currently, there is no strict specification of problem properties
+and you are free to add your own data as you see fit
+(log files, process data) provided you are planning to use
+them for reporting.
+
+Mandatory properties required prior saving:
+
+===================== ======================================================== ====================
+Property              Meaning                                                  Example
+===================== ======================================================== ====================
+``executable``        Executable path of the component which caused the        ``'/usr/bin/time'``
+                      problem.  Used by the server to determine
+                      ``component`` and ``package`` data.
+===================== ======================================================== ====================
+
+Following properties are added by the server when new problem is
+created:
+
+===================== ======================================================== ====================
+Property              Meaning                                                  Example
+===================== ======================================================== ====================
+``component``         Component which caused this problem.                     ``'time'``
+``hostname``          Hostname of the affected machine.                        ``'fiasco'``
+``os_release``        Operating system release string.                         ``'Fedora release 17 (Beefy Miracle)'``
+``uid``               User ID                                                  ``1000``
+``username``                                                                   ``'jeff'``
+``architecture``      Machine architecture string                              ``'x86_64'``
+``kernel``            Kernel version string                                    ``'3.6.6-1.fc17.x86_64'``
+``package``           Package string                                           ``'time-1.7-40.fc17.x86_64'``
+``time``              Time of the occurence (unixtime)                         ``datetime.datetime(2012, 12, 2, 16, 18, 41)``
+``count``             Number of times this problem occured                     ``1``
+===================== ======================================================== ====================
+
+Parsed package data is also available:
+
+===================== ======================================================== ====================
+Property              Meaning                                                  Example
+===================== ======================================================== ====================
+``pkg_name``          Package name                                             ``'time'``
+``pkg_epoch``         Package epoch                                            ``0``
+``pkg_version``       Package version                                          ``'1.7'``
+``pkg_release``       Package release                                          ``'40.fc17'``
+``pkg_arch``          Package architecture                                     ``'x86_64'``
+===================== ======================================================== ====================
+
+Other common properties (presence differs based on problem type):
+
+===================== ======================================================== ====================================== ===============================
+Property              Meaning                                                  Example                                Applicable
+===================== ======================================================== ====================================== ===============================
+``abrt_version``      ABRT version string                                      ``'2.0.18.84.g211c'``                  Crashes caught by ABRT
+``cgroup``            cgroup (control group) information for crashed process   ``'9:perf_event:/\n8:blkio:/\n...'``   C/C++
+``core_backtrace``    Machine readable backtrace with no private data                                                 C/C++, Python, Ruby, Kerneloops
+``backtrace``         Original backtrace or backtrace produced by retracing                                           C/C++ (after retracing), Python, Ruby, Xorg, Kerneloops
+                      process
+``dso_list``          List of dynamic libraries loaded at the time of crash                                           C/C++, Python
+``maps``              Copy of /proc/<pid>/maps file of the problem executable                                         C/C++
+``cmdline``           Copy of /proc/<pid>/cmdline file                         ``'/usr/bin/gtk-builder-convert'``     C/C++, Python, Ruby, Kerneloops
+``coredump``          Coredump of the crashing process                                                                C/C++
+``environ``           Runtime environment of the process                                                              C/C++, Python
+``open_fds``          List of file descriptors open at the time of crash                                              C/C++
+``pid``               Process ID                                               ``'42'``                               C/C++, Python, Ruby
+``proc_pid_status``   Copy of /proc/<pid>/status file                                                                 C/C++
+``limits``            Copy of /proc/<pid>/limits file                                                                 C/C++
+``var_log_messages``  Part of the /var/log/messages file which contains crash
+                      information                                                                                     C/C++
+``suspend_stats``     Copy of /sys/kernel/debug/suspend_stats                                                         Kerneloops
+``reported_to``       If the problem was already reported, this item contains                                         Reported problems
+                      URLs of the services where it was reported
+``smolt_data``        Smolt profile of the machine                                                                    Reported problems
+``event_log``         ABRT event log                                                                                  Reported problems
+``dmesg``             Copy of dmesg                                                                                   Kerneloops
+===================== ======================================================== ====================================== ===============================
diff --git a/src/python-problem/doc/usage.rst b/src/python-problem/doc/usage.rst
new file mode 100644
index 0000000..780479a
--- /dev/null
+++ b/src/python-problem/doc/usage.rst
@@ -0,0 +1,41 @@
+.. _usage:
+
+Usage examples
+==============
+
+Creating new problem
+--------------------
+
+.. literalinclude:: ../examples/daemon_example.py
+
+Creating problem for different executable
+-----------------------------------------
+
+.. literalinclude:: ../examples/selinux_example.py
+
+Adding custom data
+------------------
+
+.. literalinclude:: ../examples/userspace_example.py
+
+Querying problems
+-----------------
+
+.. literalinclude:: ../examples/list_example.py
+
+Querying all problems
+---------------------
+The ``list_all`` method will try to authenticate via 
+`polkit <http://www.freedesktop.org/wiki/Software/polkit>`_ to
+gain access to all problems on the system.
+
+If there is no authentication agent running or authentication
+is unsuccessful, the list of problems which belong to current
+user is returned (same as returned by the ``list`` method).
+
+.. literalinclude:: ../examples/list_all_example.py
+
+Editing existing problems
+-------------------------
+
+.. literalinclude:: ../examples/edit_example.py
diff --git a/src/python-problem/examples/daemon_example.py b/src/python-problem/examples/daemon_example.py
new file mode 100644
index 0000000..01c00c6
--- /dev/null
+++ b/src/python-problem/examples/daemon_example.py
@@ -0,0 +1,9 @@
+import problem
+
+prob = problem.Runtime(
+        reason='egg_error_message: assertion "error" failed',
+    )
+
+prob.add_current_process_data()
+prob.add_current_environment()
+prob.save()
diff --git a/src/python-problem/examples/edit_example.py b/src/python-problem/examples/edit_example.py
new file mode 100644
index 0000000..88d97d8
--- /dev/null
+++ b/src/python-problem/examples/edit_example.py
@@ -0,0 +1,14 @@
+import problem
+
+for prob in problem.list():
+    if prob.type == problem.JAVA:
+        prob.delete()
+
+    if prob.type == problem.CCPP:
+        if 'password' in prob.backtrace:
+            del prob.backtrace
+            prob.save()
+
+    if prob.type == problem.KERNELOOPS:
+        prob.backtrace = prob.backtrace.replace(' ?', '')
+        prob.save()
diff --git a/src/python-problem/examples/list_all_example.py b/src/python-problem/examples/list_all_example.py
new file mode 100644
index 0000000..3745a74
--- /dev/null
+++ b/src/python-problem/examples/list_all_example.py
@@ -0,0 +1,6 @@
+import problem
+
+for prob in problem.list(auth=True):
+    print(prob)
+    if hasattr(prob, 'username'):
+        print('Problem belongs to {0}'.format(prob.username))
diff --git a/src/python-problem/examples/list_example.py b/src/python-problem/examples/list_example.py
new file mode 100644
index 0000000..26aa2ed
--- /dev/null
+++ b/src/python-problem/examples/list_example.py
@@ -0,0 +1,7 @@
+import problem
+
+for prob in problem.list():
+    print(prob)
+    print(repr(prob.time))
+    if hasattr(prob, 'pid'):
+        print(prob.pid)
diff --git a/src/python-problem/examples/selinux_example.py b/src/python-problem/examples/selinux_example.py
new file mode 100644
index 0000000..428b0d0
--- /dev/null
+++ b/src/python-problem/examples/selinux_example.py
@@ -0,0 +1,7 @@
+import problem
+
+prob = problem.Selinux(reason='Front fell off')
+
+prob.executable = '/usr/bin/time'
+
+prob.save()
diff --git a/src/python-problem/examples/userspace_example.py b/src/python-problem/examples/userspace_example.py
new file mode 100644
index 0000000..24a9a2a
--- /dev/null
+++ b/src/python-problem/examples/userspace_example.py
@@ -0,0 +1,20 @@
+import problem
+
+prob = problem.Runtime(
+        reason='Error getting devices:'
+        'GDBus.Error:org.freedesktop.DBus.Error.UnknownMethod: '
+        'No such interface `org.gnome.SettingsDaemon.Power` on object at path '
+        '/org/gnome/SettingsDaemon/Power'
+    )
+
+prob.add_current_process_data()
+prob.custom_data = 'any'
+prob['dict_access_example'] = 'works'
+
+print(prob)
+print('')
+
+for key, value in prob.items():
+    print('{0}={1}'.format(key, value))
+
+print 'Identifier:', prob.save()
diff --git a/src/python-problem/problem/__init__.py b/src/python-problem/problem/__init__.py
new file mode 100644
index 0000000..7bd11c7
--- /dev/null
+++ b/src/python-problem/problem/__init__.py
@@ -0,0 +1,268 @@
+import os
+import inspect
+import datetime
+
+from problem import proxies, exception, tools
+
+JAVA = 'java'
+SELINUX = 'selinux'
+CCPP = 'CCpp'
+PYTHON = 'Python'
+KERNELOOPS = 'Kerneloops'
+RUNTIME = 'runtime'
+XORG = 'xorg'
+UNKNOWN = 'libreport'
+
+REQUIRED_FIELDS = ['executable']
+
+PROBLEM_TYPES = {
+    'JAVA' : JAVA,
+    'SELINUX': SELINUX,
+    'CCPP': CCPP,
+    'PYTHON': PYTHON,
+    'KERNELOOPS': KERNELOOPS,
+    'RUNTIME': RUNTIME,
+    'XORG': XORG,
+    'UNKNOWN': UNKNOWN,
+    }
+
+class Problem(object):
+    '''
+    Base class for the other problem types.
+
+    No need to use this class directly, use one
+    of the specific problem classes.
+
+    '''
+    def __init__(self, typ, reason):
+        self._data = dict()
+        self._dirty_data = dict()
+        self._persisted = False
+        self._proxy = None
+        self._probdir = None
+
+        self.type = typ
+        self.analyzer = typ
+        self.reason = reason
+        self._proxy = proxies.get_proxy()
+
+    def __cast(self, attr, val, reverse=False):
+        # str with digits -> int
+        if not reverse and type(val) == str and val.isdigit():
+            val = int(val)
+
+        # by attr name
+        mapping = {
+            'time': (datetime.datetime.fromtimestamp,
+                    lambda x: x.strftime('%s'))
+            }
+
+        if attr in mapping:
+            fun, revfun = mapping[attr]
+            if reverse:
+                fun = revfun
+
+            val = fun(val)
+
+        if reverse:
+            return str(val)
+
+        return val
+
+    def __getattr__(self, attr):
+        exc = AttributeError("object has no attribute '{0}'".format(attr))
+        val = None
+
+        # was deleted before?
+        if attr in self._dirty_data and self._dirty_data[attr] is None:
+            raise exc
+
+        if attr in self._data:
+            val = self._data[attr]
+
+        # try to fetch the item
+        if self._persisted:
+            val = self._proxy.get_item(self._probdir, attr)
+            self._data[attr] = val
+
+        if val is None:
+            raise exc
+
+        val = self.__cast(attr, val)
+        super(Problem, self).__setattr__(attr, val)
+
+        return val
+
+    def __setattr__(self, attr, value):
+        super(Problem, self).__setattr__(attr, value)
+        if not attr[0] == '_':
+            self._data[attr] = value
+            if self._persisted:
+                self._dirty_data[attr] = value
+
+    def __delattr__(self, attr):
+        # it might not be loaded at first
+        self.__getattr__(attr)
+        super(Problem, self).__delattr__(attr)
+        del self._data[attr]
+        if self._persisted:
+            self._dirty_data[attr] = None
+
+    def __getitem__(self, attr):
+        try:
+            return self.__getattr__(attr)
+        except AttributeError as e:
+            raise KeyError(e.message)
+
+    def __setitem__(self, attr, value):
+        self.__setattr__(attr, value)
+
+    def __delitem__(self, attr):
+        try:
+            self.__delattr__(attr)
+        except AttributeError as e:
+            raise KeyError(e.message)
+
+    def __repr__(self):
+        return '<problem.{0} ({1})>'.format(self.__class__.__name__, self.reason)
+
+    def add_current_process_data(self):
+        ''' Add pid, gid and executable of current
+        process to this problem object
+
+        '''
+        self.pid = os.getpid()
+        self.gid = os.getgid()
+        #self.executable = os.readlink('/proc/{0}/exe'.format(os.getpid()))
+        # ^ always '/usr/bin/python' so we need:
+        self.executable = os.path.abspath(inspect.stack()[-1][1])
+
+    def add_current_environment(self):
+        ''' Add environment of current process to this problem object '''
+        self.environ = ''
+        for key, value in os.environ.iteritems():
+            self.environ += '{0}={1}\n'.format(key, value)
+
+    def items(self):
+        return self._data.items()
+
+    def validate(self):
+        for field in REQUIRED_FIELDS:
+            if not hasattr(self, field):
+                raise exception.ValidationError(
+                     'Missing required field {0}'.format(field))
+
+    def save(self):
+        ''' Create this problem or update modified data
+
+        Create or update the project if some of its fields
+        were modified.
+
+        Return ``None`` in case of modification, identifier
+        if new problem was created.
+
+        '''
+        self.validate()
+
+        # convert to strings
+        str_data = dict()
+        for key, value in self._data.iteritems():
+            str_data[str(key)] = self.__cast(key, value, reverse=True)
+
+        # already persisted?
+        if self._persisted:
+            for key, value in self._dirty_data.iteritems():
+                if value is None:
+                    self._proxy.del_item(self._probdir, key)
+                else:
+                    self._proxy.set_item(self._probdir, key,
+                        self.__cast(key, value, reverse=True))
+
+            self._dirty_data = dict()
+        else:
+            # create
+            ret = self._proxy.create(str_data)
+            self._persisted = True
+            self._probdir = str(ret)
+            return self._probdir
+
+    def delete(self):
+        ''' Delete this problem '''
+        if self._persisted:
+            self._proxy.delete(self._probdir)
+            self._persisted = False
+            self._probdir = None
+            self._dirty_data = {}
+
+class Java(Problem):
+    ''' Java problem '''
+    def __init__(self, reason):
+        super(Java, self).__init__(JAVA, reason)
+
+class Selinux(Problem):
+    ''' Selinux problem '''
+    def __init__(self, reason):
+        super(Selinux, self).__init__(SELINUX, reason)
+
+class Ccpp(Problem):
+    ''' C, C++ problem '''
+    def __init__(self, reason):
+        super(Ccpp, self).__init__(CCPP, reason)
+
+class Python(Problem):
+    ''' Python problem '''
+    def __init__(self, reason):
+        super(Python, self).__init__(PYTHON, reason)
+
+class Kerneloops(Problem):
+    ''' Kerneloops problem '''
+    def __init__(self, reason):
+        super(Kerneloops, self).__init__(KERNELOOPS, reason)
+
+class Xorg(Problem):
+    ''' Xorg problem '''
+    def __init__(self, reason):
+        super(Xorg, self).__init__(XORG, reason)
+
+class Runtime(Problem):
+    ''' Runtime problem '''
+    def __init__(self, reason):
+        super(Runtime, self).__init__(RUNTIME, reason)
+
+class Unknown(Problem):
+    ''' Unknown problem '''
+    def __init__(self, reason):
+        super(Unknown, self).__init__('libreport', reason)
+
+def list(auth=False, __proxy = proxies.get_proxy()):
+    ''' Return the list of the problems
+
+    Use ``auth=True`` if authentication should be attempted.
+
+    If authentication via polkit fails, function behaves
+    as if ``auth=False`` was specified (only users problems are
+    returned).
+    '''
+    fun = __proxy.list
+    if auth:
+        fun = __proxy.list_all
+
+    return map(lambda x: tools.problemify(x, __proxy), fun())
+
+def get(identifier, auth=False, __proxy = proxies.get_proxy()):
+    ''' Return problem object matching ``identifier``
+
+    Return ``None`` in case the problem does not exist.
+
+    Use ``auth=True`` if authentication should be attempted.
+
+    '''
+
+    fun = __proxy.list
+    if auth:
+        lst = __proxy.list_all
+
+    if identifier not in fun():
+        return None
+
+    return tools.problemify(identifier, __proxy)
diff --git a/src/python-problem/problem/exception.py b/src/python-problem/problem/exception.py
new file mode 100644
index 0000000..3e1fa9b
--- /dev/null
+++ b/src/python-problem/problem/exception.py
@@ -0,0 +1,11 @@
+class AuthFailure(Exception):
+    pass
+
+class InvalidProblem(Exception):
+    pass
+
+class UnavailableSource(Exception):
+    pass
+
+class ValidationError(Exception):
+    pass
diff --git a/src/python-problem/problem/proxies.py b/src/python-problem/problem/proxies.py
new file mode 100644
index 0000000..5db4002
--- /dev/null
+++ b/src/python-problem/problem/proxies.py
@@ -0,0 +1,126 @@
+import logging
+
+import problem.exception
+
+class DBusProxy(object):
+    __instance = None
+
+    def __init__(self, dbus):
+        self._proxy = None
+        self._iface = None
+        self.dbus = dbus
+        self.connected = False
+        self.connect()
+
+    def __new__(cls, *args, **kwargs):
+        if not cls.__instance:
+            cls.__instance = super(DBusProxy, cls).__new__(
+                                    cls, *args, **kwargs)
+        return cls.__instance
+
+    def connect(self):
+        self.connected = False
+        if self._proxy:
+            self._proxy.close()
+        try:
+            self._proxy = self.dbus.SystemBus().get_object(
+                'org.freedesktop.problems', '/org/freedesktop/problems')
+        except self.dbus.exceptions.DBusException as e:
+            logging.debug('Unable to get dbus proxy: {0}'.format(e.message))
+            return
+
+        try:
+            self._iface = self.dbus.Interface(self._proxy,
+                'org.freedesktop.problems')
+        except self.dbus.exceptions.DBusException as e:
+            logging.debug('Unable to get dbus interface: {0}'.format(e.message))
+            return
+
+        self.connected = True
+
+    def _dbus_call(self, fun_name, *args):
+        try:
+            return getattr(self._iface, fun_name)(*args)
+        except self.dbus.exceptions.DBusException as e:
+            dbname = e.get_dbus_name()
+            if dbname == "org.freedesktop.DBus.Error.ServiceUnknown":
+                self.connect()
+                return getattr(self._iface, fun_name)(*args)
+
+            if dbname == 'org.freedesktop.problems.AuthFailure':
+                raise problem.exception.AuthFailure(e.message)
+
+            if dbname == 'org.freedesktop.problems.InvalidProblemDir':
+                raise problem.exception.InvalidProblem(e.message)
+
+            raise
+
+    def get_item(self, dump_dir, name):
+        val = self._dbus_call('GetInfo', dump_dir, [name])
+        if name not in val:
+            return None
+
+        return str(val[name])
+
+    def set_item(self, dump_dir, name, value):
+        return self._dbus_call('SetElement', dump_dir, name, value)
+
+    def del_item(self, dump_dir, name):
+        return self._dbus_call('DeleteElement', dump_dir, name)
+
+    def create(self, problem_dict):
+        return self._dbus_call('NewProblem', problem_dict)
+
+    def delete(self, dump_dir):
+        return self._dbus_call('DeleteProblem', dump_dir)
+
+    def list(self):
+        return map(str, self._dbus_call('GetProblems'))
+
+    def list_all(self):
+        return map(str, self._dbus_call('GetAllProblems'))
+
+class SocketProxy(object):
+    def create(self, problem_dict):
+        import socket
+        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
+        sock.settimeout(5)
+        try:
+            sock.connect('/var/run/abrt/abrt.socket')
+            sock.sendall("PUT / HTTP/1.1\r\n\r\n")
+            for key, value in problem_dict.iteritems():
+                sock.sendall('{0}={1}\0'.format(key.upper(), value))
+
+            sock.shutdown(socket.SHUT_WR)
+            resp = ''
+            while True:
+                buf = sock.recv(256)
+                if not buf:
+                    break
+                resp += buf
+            return resp
+        except socket.timeout as exc:
+            logging.error('communication with daemon failed: {0}'.format(exc))
+            return None
+
+    def get_item(self, *args):
+        raise NotImplementedError
+    def set_item(self, *args):
+        raise NotImplementedError
+    def del_item(self, *args):
+        raise NotImplementedError
+    def delete(self, *args):
+        raise NotImplementedError
+    def list(self, *args):
+        raise NotImplementedError
+
+def get_proxy():
+    try:
+        import dbus
+        wrapper = DBusProxy(dbus)
+        if wrapper.connected:
+            return wrapper
+    except ImportError:
+        logging.debug('DBus not found')
+
+    return SocketProxy()
diff --git a/src/python-problem/problem/tools.py b/src/python-problem/problem/tools.py
new file mode 100644
index 0000000..892ba2e
--- /dev/null
+++ b/src/python-problem/problem/tools.py
@@ -0,0 +1,19 @@
+import problem
+
+def problemify(probdir, proxy):
+    by_analyzer = dict(zip(problem.PROBLEM_TYPES.values(), 
+        problem.PROBLEM_TYPES.keys()))
+
+    analyzer = proxy.get_item(probdir, 'analyzer')
+    reason = proxy.get_item(probdir, 'reason')
+
+    if analyzer not in by_analyzer:
+        return problem.Unknown(reason)
+
+    class_name = by_analyzer[analyzer].lower().capitalize()
+
+    prob = getattr(problem, class_name)(reason)
+    prob._probdir = probdir
+    prob._persisted = True
+    prob._proxy = proxy
+    return prob
diff --git a/src/python-problem/test b/src/python-problem/test
new file mode 100755
index 0000000..7413d47
--- /dev/null
+++ b/src/python-problem/test
@@ -0,0 +1,2 @@
+#!/bin/bash
+nosetests --with-coverage --cover-package=problem --nocapture --nologcapture --no-skip --verbose
diff --git a/src/python-problem/tests/base.py b/src/python-problem/tests/base.py
new file mode 100644
index 0000000..214a58a
--- /dev/null
+++ b/src/python-problem/tests/base.py
@@ -0,0 +1,15 @@
+import unittest
+
+from util import FakeProxy
+
+import problem
+
+class ProblematicTestCase(unittest.TestCase):
+    def setUp(self):
+        self.proxy = FakeProxy()
+        #self.proxy = problem.proxies.get_proxy()
+
+    def create_problem(self):
+        prob = problem.Runtime(reason='Front fell off')
+        prob._proxy = self.proxy
+        return prob
diff --git a/src/python-problem/tests/test_api.py b/src/python-problem/tests/test_api.py
new file mode 100644
index 0000000..22f874e
--- /dev/null
+++ b/src/python-problem/tests/test_api.py
@@ -0,0 +1,351 @@
+import os
+import time
+import logging
+import datetime
+import unittest
+
+from nose import tools
+
+from base import ProblematicTestCase
+
+import problem
+
+class ProblemAPITestCase(ProblematicTestCase):
+    def test_init(self):
+        prob = self.create_problem()
+
+        tools.eq_(prob.type, problem.RUNTIME)
+        tools.eq_(prob.analyzer, problem.RUNTIME)
+        tools.eq_(prob.reason, 'Front fell off')
+
+    def test_add_current_process_data(self):
+        prob = self.create_problem()
+
+        prob.add_current_process_data()
+        tools.eq_(prob.pid, os.getpid())
+        tools.eq_(prob.gid, os.getgid())
+        tools.ok_(
+            '<stdin>'  in prob.executable or
+            'tests.py' in prob.executable or
+            'nosetest' in prob.executable)
+
+    def test_getattr(self):
+        prob = self.create_problem()
+
+        tools.eq_(prob.reason, 'Front fell off')
+
+        with self.assertRaises(AttributeError):
+            prob.non_existent
+
+        with self.assertRaises(AttributeError):
+            prob.non_existent_method()
+
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        self.proxy.set_item(ident, 'test', 'wat')
+        tools.eq_(prob.test, 'wat')
+
+        with self.assertRaises(AttributeError):
+            prob.persisted_non_existent
+
+        with self.assertRaises(AttributeError):
+            prob.persisted_non_existent_method()
+
+        prob.delete()
+
+    def test_getattr_on_deleted(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+
+        prob.save()
+        del prob.executable
+
+        with self.assertRaises(AttributeError):
+            prob.executable
+
+        prob.delete()
+
+    def test_getattr_on_persisted(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+
+        ident = prob.save()
+
+        self.proxy.set_item(ident, 'test', 1)
+
+        tools.eq_(prob.test, 1)
+
+        prob.delete()
+
+    def test_getitem(self):
+        prob = self.create_problem()
+
+        tools.eq_(prob['reason'], 'Front fell off')
+
+        with self.assertRaises(KeyError):
+            prob['non_existent']
+
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        self.proxy.set_item(ident, 'test', 'wat')
+        tools.eq_(prob['test'], 'wat')
+
+        with self.assertRaises(KeyError):
+            prob['persisted_non_existent']
+
+        prob.delete()
+
+    def test_setattr(self):
+        prob = self.create_problem()
+
+        prob.test = 'x'
+        tools.eq_(prob.test, 'x')
+
+        prob._test = 'y'
+        tools.eq_(prob._test, 'y')
+
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        tools.eq_(self.proxy.get_item(ident, 'test'), 'x')
+        tools.eq_(self.proxy.get_item(ident, '_test'), None)
+
+        prob.delete()
+
+    def test_setattr_on_persisted(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+
+        ident = prob.save()
+
+        self.proxy.set_item(ident, 'test', 'wat')
+
+        prob.test = '14'
+        prob.save()
+
+        tools.eq_(self.proxy.get_item(ident, 'test'), '14')
+
+        prob.delete()
+
+
+    def test_setitem(self):
+        prob = self.create_problem()
+
+        prob['test'] = 'x'
+        tools.eq_(prob.test, 'x')
+        tools.eq_(prob['test'], 'x')
+
+        prob['_test'] = 'y'
+
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        tools.eq_(self.proxy.get_item(ident, 'test'), 'x')
+        tools.eq_(self.proxy.get_item(ident, '_test'), None)
+
+        prob.delete()
+
+    def test_delattr(self):
+        prob = self.create_problem()
+        del prob.reason
+        with self.assertRaises(AttributeError):
+            prob.reason
+
+        with self.assertRaises(AttributeError):
+            del prob.non_existent
+
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        tools.eq_(self.proxy.get_item(ident, 'reason'), None)
+
+        del prob.type
+        prob.save()
+
+        tools.eq_(self.proxy.get_item(ident, 'type'), None)
+
+        prob.delete()
+
+    def test_delattr_on_persisted(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+
+        ident = prob.save()
+
+        self.proxy.set_item(ident, 'test', 'wat')
+
+        del prob.test
+
+        with self.assertRaises(AttributeError):
+            del prob.test
+
+        prob.save()
+
+        tools.eq_(self.proxy.get_item(ident, 'test'), None)
+
+        prob.delete()
+
+    def test_delitem(self):
+        prob = self.create_problem()
+
+        del prob['reason']
+        with self.assertRaises(KeyError):
+            prob['reason']
+
+        with self.assertRaises(KeyError):
+            del prob['non_existent']
+
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        tools.eq_(self.proxy.get_item(ident, 'reason'), None)
+
+        del prob['type']
+        prob.save()
+
+        tools.eq_(self.proxy.get_item(ident, 'type'), None)
+
+        prob.delete()
+
+    def test_int_cast(self):
+        prob = self.create_problem()
+
+        prob.add_current_process_data()
+        prob['mynumerical'] = 15
+        ident = prob.save()
+
+        tools.eq_(self.proxy.get_item(ident, 'mynumerical'), '15')
+        self.proxy.set_item(ident, 'numerical', '123')
+
+        tools.eq_(prob.numerical, 123)
+
+        prob.delete()
+
+    def test_time_cast(self):
+        prob = self.create_problem()
+
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        saved_time = int(time.time())
+        self.proxy.set_item(ident, 'time', str(saved_time))
+        cast_time = prob.time
+
+        tools.eq_(cast_time, datetime.datetime.fromtimestamp(int(saved_time)))
+        tools.eq_(type(cast_time), datetime.datetime)
+
+        prob.time += datetime.timedelta(days=3)
+        prob.save()
+
+        updated_time = self.proxy.get_item(ident, 'time')
+
+        tools.ok_(type(updated_time), str)
+        tools.ok_(updated_time != saved_time)
+
+        prob.delete()
+
+    def test_add_current_environment(self):
+        prob = self.create_problem()
+
+        prob.add_current_environment()
+
+        for key, value in os.environ.iteritems():
+            tools.ok_('{0}={1}'.format(key, value) in prob.environ)
+
+    def test_save_delete(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+
+        path = prob.save()
+        tools.ok_('runtime-' in path)
+
+    def test_repr(self):
+        prob = self.create_problem()
+        ret = repr(prob)
+        tools.ok_('problem.Runtime' in ret)
+        tools.ok_('(Front fell off)' in ret)
+
+    def test_items(self):
+        prob = self.create_problem()
+        for key, value in prob.items():
+            tools.eq_(prob[key], value)
+
+    def test_validate(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        prob.validate()
+
+        del prob.executable
+        with self.assertRaises(problem.exception.ValidationError):
+            prob.validate()
+
+    def test_invalidproblem(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        ident = prob.save()
+        prob.delete()
+
+        with self.assertRaises(problem.exception.InvalidProblem):
+            self.proxy.get_item(ident, 'reason')
+
+    def test_save(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        tools.eq_(self.proxy.get_item(ident, 'type'), problem.RUNTIME)
+        tools.eq_(self.proxy.get_item(ident, 'analyzer'), problem.RUNTIME)
+        tools.eq_(self.proxy.get_item(ident, 'reason'), 'Front fell off')
+        tools.ok_(self.proxy.get_item(ident, 'pid') is not None)
+        tools.ok_(self.proxy.get_item(ident, 'gid') is not None)
+        tools.ok_(self.proxy.get_item(ident, 'executable') is not None)
+
+        prob.delete()
+
+    def test_dirty_save(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        prob.executable = 'nine'
+        prob.save()
+
+        tools.eq_(self.proxy.get_item(ident, 'executable'), 'nine')
+
+        prob.delete()
+
+    def test_delete(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        tools.ok_(ident in self.proxy.list())
+
+        prob.delete()
+
+        tools.ok_(ident not in self.proxy.list())
+
+    def test_delete_then_save(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        ident = prob.save()
+        prob.delete()
+        ident2 = prob.save()
+
+        tools.ok_(ident != ident2)
+
+    def test_problem_types(self):
+        for ptype, internal in problem.PROBLEM_TYPES.items():
+            class_name = ptype.lower().capitalize()
+            prinstance = getattr(problem, class_name)('Front fell off')
+            tools.eq_(prinstance.type, internal)
+            tools.eq_(prinstance.analyzer, internal)
+
+        unpr = problem.Unknown('Front not found')
+        tools.eq_(unpr.type, 'libreport')
+
+if __name__ == '__main__':
+    logging.basicConfig(level=logging.DEBUG)
+    unittest.main()
diff --git a/src/python-problem/tests/test_get.py b/src/python-problem/tests/test_get.py
new file mode 100644
index 0000000..0ebb395
--- /dev/null
+++ b/src/python-problem/tests/test_get.py
@@ -0,0 +1,22 @@
+from nose import tools
+
+from base import ProblematicTestCase
+
+import problem
+
+class GetTestCase(ProblematicTestCase):
+    def test_get(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        prob2 = problem.get(ident, False, self.proxy)
+        prob3 = problem.get(ident, True, self.proxy)
+
+        tools.eq_(prob.reason, prob2.reason)
+        tools.eq_(prob.reason, prob3.reason)
+
+        prob.delete()
+
+    def test_get_nonexistent(self):
+        tools.ok_(problem.get('random', False, self.proxy) is None)
diff --git a/src/python-problem/tests/test_internal.py b/src/python-problem/tests/test_internal.py
new file mode 100644
index 0000000..9d7ab81
--- /dev/null
+++ b/src/python-problem/tests/test_internal.py
@@ -0,0 +1,120 @@
+from nose import tools
+
+from base import ProblematicTestCase
+
+import problem
+
+class InternalProblemImplementationTestCase(ProblematicTestCase):
+    def test_init(self):
+        prob = self.create_problem()
+        tools.eq_(prob._proxy, self.proxy )
+
+    def test_setattr(self):
+        prob = self.create_problem()
+
+        prob.test = 0
+        tools.eq_(prob._data['test'], 0)
+        tools.eq_(prob._dirty_data, {})
+
+        prob._test = 1
+        tools.eq_(prob._test, 1)
+        tools.ok_('_test' not in prob._data)
+
+        prob.add_current_process_data()
+        prob.save()
+
+        prob.persisted_test = 0
+        tools.eq_(prob._data['persisted_test'], 0)
+        tools.eq_(prob._dirty_data['persisted_test'], 0)
+
+        prob.delete()
+
+    def test_setitem(self):
+        prob = self.create_problem()
+
+        prob['test'] = 0
+        tools.eq_(prob._data['test'], 0)
+        tools.eq_(prob._dirty_data, {})
+
+        prob['_test'] = 1
+        tools.ok_('_test' not in prob._data)
+
+        prob.add_current_process_data()
+        prob.save()
+
+        prob['persisted_test'] = 0
+        tools.eq_(prob._data['persisted_test'], 0)
+        tools.eq_(prob._dirty_data['persisted_test'], 0)
+
+        prob.delete()
+
+    def test_delattr(self):
+        prob = self.create_problem()
+        del prob.reason
+        tools.ok_('reason' not in prob._data)
+
+        prob.add_current_process_data()
+        prob.save()
+
+        del prob.type
+        tools.eq_(prob._dirty_data, {'type': None})
+
+        prob.save()
+
+        tools.eq_(prob._dirty_data, {})
+
+        prob.delete()
+
+    def test_delitem(self):
+        prob = self.create_problem()
+        del prob['reason']
+        tools.ok_('reason' not in prob._data)
+
+        prob.add_current_process_data()
+        prob.save()
+
+        del prob['type']
+        tools.eq_(prob._dirty_data, {'type': None})
+
+        prob.save()
+
+        tools.eq_(prob._dirty_data, {})
+
+        prob.delete()
+
+    def test_items(self):
+        prob = problem.Runtime('Massive error')
+        tools.eq_(prob.items(), prob._data.items())
+
+    def test_save(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        tools.eq_(prob._probdir, ident)
+
+        prob.delete()
+
+    def test_dirty_save(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        prob.executable = 'nine'
+
+        tools.eq_(prob._dirty_data['executable'], 'nine')
+        prob.save()
+        tools.eq_(prob._dirty_data, {})
+
+        prob.delete()
+
+    def test_delete(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        prob.delete()
+
+        tools.eq_(prob._persisted, False)
+        tools.eq_(prob._probdir, None)
+        tools.eq_(prob._dirty_data, {})
diff --git a/src/python-problem/tests/test_list.py b/src/python-problem/tests/test_list.py
new file mode 100644
index 0000000..5c98c87
--- /dev/null
+++ b/src/python-problem/tests/test_list.py
@@ -0,0 +1,27 @@
+from nose import tools
+
+from base import ProblematicTestCase
+
+import problem
+
+class ListTestCase(ProblematicTestCase):
+    def test_list(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        tools.ok_(ident in map(lambda x: x._probdir,
+            problem.list(False, self.proxy)))
+
+        prob.delete()
+
+    def test_list_all(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        tools.ok_(ident in map(lambda x: x._probdir,
+            problem.list(True, self.proxy)))
+
+        prob.delete()
+
diff --git a/src/python-problem/tests/test_tools.py b/src/python-problem/tests/test_tools.py
new file mode 100644
index 0000000..9cf3d51
--- /dev/null
+++ b/src/python-problem/tests/test_tools.py
@@ -0,0 +1,30 @@
+from nose import tools
+
+from base import ProblematicTestCase
+
+import problem
+
+class ProblemifyTestCase(ProblematicTestCase):
+    def test_problemify(self):
+        prob = self.create_problem()
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        prob2 = problem.tools.problemify(ident, self.proxy)
+
+        tools.eq_(type(prob), type(prob2))
+        tools.eq_(prob.type, prob2.type)
+        tools.eq_(prob.analyzer, prob2.analyzer)
+        tools.eq_(prob.reason, prob2.reason)
+        tools.eq_(prob.executable, prob2.executable)
+
+        prob.delete()
+
+    def test_problemify_unknown(self):
+        prob = problem.Unknown('Front not found')
+        prob._proxy = self.proxy
+        prob.add_current_process_data()
+        ident = prob.save()
+
+        prob2 = problem.tools.problemify(ident, self.proxy)
+        tools.eq_(type(prob2), problem.Unknown)
diff --git a/src/python-problem/tests/util.py b/src/python-problem/tests/util.py
new file mode 100644
index 0000000..5dd9175
--- /dev/null
+++ b/src/python-problem/tests/util.py
@@ -0,0 +1,36 @@
+import datetime
+
+import problem
+
+class FakeProxy(object):
+    data = dict()
+
+    def get_item(self, dump_dir, name):
+        if dump_dir not in self.data:
+            raise problem.exception.InvalidProblem()
+
+        try:
+            return self.data[dump_dir][name]
+        except KeyError:
+            return None
+
+    def set_item(self, dump_dir, name, value):
+        self.data[dump_dir][name] = value
+
+    def del_item(self, dump_dir, name):
+        del self.data[dump_dir][name]
+
+    def create(self, problem_dict):
+        datestr = str(datetime.datetime.now()).replace(' ', '-')
+        name = '{0}-{1}'.format(problem_dict['type'], datestr)
+        self.data[name] = problem_dict
+        return name
+
+    def delete(self, dump_dir):
+        del self.data[dump_dir]
+
+    def list(self):
+        return self.data.keys()
+
+    def list_all(self):
+        return self.data.keys()
-- 
1.8.2.1

