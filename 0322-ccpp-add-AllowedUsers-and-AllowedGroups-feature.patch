From 5ca2fe448695c3c90a6001b96c87f8424dc5bb2e Mon Sep 17 00:00:00 2001
From: Matej Habrnal <mhabrnal@redhat.com>
Date: Wed, 16 Dec 2015 18:20:07 +0100
Subject: [PATCH] ccpp: add AllowedUsers and AllowedGroups feature

The feature allows dump core only for allowed users.

The logic is the following:
 - if both options are not-defined or empty keep all core dumps
 - else if crashed UID is in the list of users keep the core dump
 - else if crashed UID belongs to a group in the list of groups keep the core dump

Related to rhbz#1256705

Signed-off-by: Matej Habrnal <mhabrnal@redhat.com>
---
 src/hooks/CCpp.conf        |    7 ++++
 src/hooks/abrt-hook-ccpp.c |   67 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 74 insertions(+), 0 deletions(-)

diff --git a/src/hooks/CCpp.conf b/src/hooks/CCpp.conf
index 2c7944c..e9ba618 100644
--- a/src/hooks/CCpp.conf
+++ b/src/hooks/CCpp.conf
@@ -24,3 +24,10 @@ SaveBinaryImage = no
 # specified patterns.
 #
 #IgnoredPaths =
+
+# ABRT will process only crashes of either allowed users or users who are
+# members of allowed group. If no allowed users nor allowed group are specified
+# ABRT will process crashes of all users.
+#
+#AllowedUsers =
+#AllowedGroups =
diff --git a/src/hooks/abrt-hook-ccpp.c b/src/hooks/abrt-hook-ccpp.c
index 896ad97..b41e252 100644
--- a/src/hooks/abrt-hook-ccpp.c
+++ b/src/hooks/abrt-hook-ccpp.c
@@ -702,6 +702,44 @@ static bool is_path_ignored(const GList *list, const char *path)
     return false;
 }
 
+static bool is_user_allowed(uid_t uid, const GList *list)
+{
+    const GList *li;
+    for (li = list; li != NULL; li = g_list_next(li))
+    {
+        const char *username = (const char*)li->data;
+        struct passwd *pw = getpwnam(username);
+        if (pw == NULL)
+        {
+            VERB1 log("can't get uid of user '%s' (listed in 'AllowedUsers')", username);
+            continue;
+        }
+
+        if(pw->pw_uid == uid)
+            return true;
+    }
+    return false;
+}
+
+static bool is_user_in_allowed_group(uid_t uid, const GList *list)
+{
+    const GList *li;
+    for (li = list; li != NULL; li = g_list_next(li))
+    {
+        const char *groupname = (const char*)li->data;
+        struct group *gr = getgrnam(groupname);
+        if (gr == NULL)
+        {
+            VERB1 log("can't get gid of group '%s' (listed in 'AllowedGroups')", groupname);
+            continue;
+        }
+
+        if(uid_in_group(uid, gr->gr_gid))
+            return true;
+    }
+    return false;
+}
+
 /* Like other glibc functions this one also return 0 on logical true, positive
  * number on logical false and negative number on error. */
 static int process_is_syslog(pid_t pid)
@@ -848,6 +886,8 @@ int main(int argc, char** argv)
     bool setting_MakeCompatCore;
     bool setting_SaveBinaryImage;
     GList *setting_ignored_paths = NULL;
+    GList *setting_allowed_users = NULL;
+    GList *setting_allowed_groups = NULL;
     {
         map_string_t *settings = new_map_string();
         load_abrt_plugin_conf_file("CCpp.conf", settings);
@@ -862,6 +902,14 @@ int main(int argc, char** argv)
         value = get_map_string_item_or_NULL(settings, "IgnoredPaths");
         if (value)
             setting_ignored_paths = parse_list(value);
+
+        value = get_map_string_item_or_NULL(settings, "AllowedUsers");
+        if (value)
+            setting_allowed_users = parse_list(value);
+        value = get_map_string_item_or_NULL(settings, "AllowedGroups");
+        if (value)
+            setting_allowed_groups = parse_list(value);
+
         free_map_string(settings);
     }
 
@@ -975,6 +1023,25 @@ int main(int argc, char** argv)
         return 0;
     }
 
+     /* dumping core for user, if allowed */
+    if (setting_allowed_users || setting_allowed_groups)
+    {
+        if (setting_allowed_users && is_user_allowed(uid, setting_allowed_users))
+        {
+            VERB3 log("User %lu is listed in 'AllowedUsers'", (long unsigned)uid);
+        }
+        else if (setting_allowed_groups && is_user_in_allowed_group(uid, setting_allowed_groups))
+        {
+            VERB3 log("User %lu is member of group listed in 'AllowedGroups'", (long unsigned)uid);
+        }
+        else
+        {
+            error_msg_not_process_crash(pid_str, last_slash+1, (long unsigned)uid, signal_no,
+                signame, "ignoring (not allowed in 'AllowedUsers' nor 'AllowedGroups')");
+
+            xfunc_die();
+        }
+    }
 
     if (!daemon_is_ok())
     {
-- 
1.7.1

