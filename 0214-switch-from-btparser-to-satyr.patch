From d3e78483a2afc0d701874701c9ddfcfac1f43333 Mon Sep 17 00:00:00 2001
From: Jakub Filak <jfilak@redhat.com>
Date: Fri, 2 May 2014 09:50:34 +0200
Subject: [ABRT PATCH] switch from btparser to satyr

Signed-off-by: Jakub Filak <jfilak@redhat.com>
---
 configure.ac                                      |   2 +-
 src/daemon/Makefile.am                            |   4 +-
 src/daemon/abrt-handle-event.c                    | 283 +++----
 src/include/libabrt.h                             |   7 +-
 src/lib/Makefile.am                               |   4 +-
 src/lib/hooklib.c                                 | 144 +++-
 src/lib/kernel.c                                  | 160 +---
 src/plugins/Makefile.am                           |   6 +-
 src/plugins/abrt-action-analyze-backtrace.c       |  66 +-
 src/plugins/abrt-action-analyze-c.c               |  14 +-
 src/plugins/abrt-action-analyze-python.c          |  13 +-
 src/plugins/abrt-action-generate-backtrace.c      | 132 +---
 src/plugins/abrt-action-generate-core-backtrace.c | 916 +---------------------
 src/plugins/ccpp_event.conf                       |   2 +-
 14 files changed, 382 insertions(+), 1371 deletions(-)

diff --git a/configure.ac b/configure.ac
index 1cbc76f..54a8cc3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -68,7 +68,7 @@ PKG_CHECK_MODULES([LIBXML], [libxml-2.0])
 PKG_CHECK_MODULES([RPM], [rpm])
 PKG_CHECK_MODULES([LIBNOTIFY], [libnotify])
 PKG_CHECK_MODULES([NSS], [nss])
-PKG_CHECK_MODULES([BTPARSER], [btparser])
+PKG_CHECK_MODULES([SATYR], [satyr])
 PKG_CHECK_MODULES([LIBREPORT], [libreport])
 PKG_CHECK_MODULES([LIBREPORT_GTK], [libreport-gtk])
 # Just PKG_CHECK_MODULES([PYTHON], [python]) works only with python2.7+
diff --git a/src/daemon/Makefile.am b/src/daemon/Makefile.am
index d79ffc2..3cfd61e 100644
--- a/src/daemon/Makefile.am
+++ b/src/daemon/Makefile.am
@@ -75,13 +75,13 @@ abrt_handle_event_CPPFLAGS = \
     -I$(srcdir)/../lib \
     $(GLIB_CFLAGS) \
     $(LIBREPORT_CFLAGS) \
-    $(BTPARSER_CFLAGS) \
+    $(SATYR_CFLAGS) \
     -D_GNU_SOURCE \
     -Wall -Wwrite-strings -Werror
 abrt_handle_event_LDADD = \
     ../lib/libabrt.la \
     $(LIBREPORT_LIBS) \
-    $(BTPARSER_LIBS)
+    $(SATYR_LIBS)
 
 abrt_action_save_package_data_SOURCES = \
     rpm.h rpm.c \
diff --git a/src/daemon/abrt-handle-event.c b/src/daemon/abrt-handle-event.c
index 9d1da4a..bdab244 100644
--- a/src/daemon/abrt-handle-event.c
+++ b/src/daemon/abrt-handle-event.c
@@ -16,198 +16,96 @@
     with this program; if not, write to the Free Software Foundation, Inc.,
     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
+#include <satyr/thread.h>
+#include <satyr/stacktrace.h>
+#include <satyr/distance.h>
+#include <satyr/abrt.h>
 
 #include "libabrt.h"
 #include "run_event.h"
 
-#include <btparser/frame.h>
-#include <btparser/thread.h>
-#include <btparser/normalize.h>
-#include <btparser/metrics.h>
-
-#define BACKTRACE_TRUNCATE_LENGTH 7
-#define BACKTRACE_DUP_THRESHOLD 2
+/* 70 % similarity */
+#define BACKTRACE_DUP_THRESHOLD 0.3
 
 static char *uid = NULL;
 static char *uuid = NULL;
-static struct btp_thread *corebt = NULL;
+static struct sr_stacktrace *corebt = NULL;
+static char *analyzer = NULL;
 static char *crash_dump_dup_name = NULL;
 
-struct frame_aux
-{
-    char *build_id;
-    char *modname;
-    char *fingerprint;
-};
+static void dup_corebt_fini(void);
 
-static void free_frame_aux(void *user_data)
+static char* load_backtrace(const struct dump_dir *dd)
 {
-    struct frame_aux *aux = user_data;
-
-    if (aux)
+    const char *filename = FILENAME_BACKTRACE;
+    if (strcmp(analyzer, "CCpp") == 0)
     {
-        free(aux->build_id);
-        free(aux->modname);
-        free(aux->fingerprint);
-        free(aux);
+        filename = FILENAME_CORE_BACKTRACE;
     }
-}
-
-#if 0
-/* Useful only for debugging. */
-static void print_thread(const struct btp_thread *thread)
-{
-    struct btp_frame *frame;
 
-    for (frame = thread->frames; frame != NULL; frame = frame->next)
-    {
-        struct frame_aux *aux = frame->user_data;
-        printf("%s %s+0x%jx %s %s\n", frame->function_name, aux->build_id,
-                (uintmax_t)frame->address, aux->modname, aux->fingerprint);
-    }
+    return dd_load_text_ext(dd, filename,
+        DD_FAIL_QUIETLY_ENOENT|DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);
 }
-#endif
 
-static char *read_string(const char **inptr)
+static int core_backtrace_is_duplicate(struct sr_stacktrace *bt1,
+                                       const char *bt2_text)
 {
-    const char *cur = *inptr;
-    const char *str;
-    int len;
-
-    cur = skip_whitespace(cur);
-    str = cur;
-    cur = skip_non_whitespace(cur);
+    struct sr_thread *thread1 = sr_stacktrace_find_crash_thread(bt1);
 
-    len = cur-str;
-    *inptr = cur;
-
-    if (len == 1 && *str == '-')
+    if (thread1 == NULL)
     {
-        return NULL;
+        VERB1 log("New stacktrace has no crash thread, disabling core stacktrace deduplicate");
+        dup_corebt_fini();
+        return 0;
     }
 
-    return xstrndup(str, len);
-}
-
-static struct btp_thread* load_core_backtrace(const char *text)
-{
-    const char *cur = text;
-    int ret;
-    int chars_read;
-    uintmax_t off;
-
-    struct btp_thread *thread = xzalloc(sizeof(*thread));
-    struct btp_frame **prev_link = &(thread->frames);
-
-    /* Parse the text. */
-    while (*cur)
+    int result;
+    char *error_message;
+    struct sr_stacktrace *bt2 = sr_stacktrace_parse(sr_abrt_type_from_analyzer(analyzer),
+                                                    bt2_text, &error_message);
+    if (bt2 == NULL)
     {
-        struct btp_frame *frame = xzalloc(sizeof(*frame));
-        btp_frame_init(frame);
-        struct frame_aux *aux = xzalloc(sizeof(*aux));
-        frame->user_data = aux;
-        frame->user_data_destructor = free_frame_aux;
-        *prev_link = frame;
-        prev_link = &(frame->next);
-
-        /* BUILD ID */
-        aux->build_id = read_string(&cur);
-
-        /* OFFSET */
-        cur = skip_whitespace(cur);
-        ret = sscanf(cur, "0x%jx %n", &off, &chars_read);
-        if (ret < 1)
-        {
-            btp_thread_free(thread);
-            VERB1 log("Error parsing core backtrace");
-            return NULL;
-        }
-        cur += chars_read;
-        frame->address = (uint64_t)off;
-
-        /* SYMBOL */
-        char *symbol = read_string(&cur);
-        /* btparser uses "??" to denote unknown function name */
-        frame->function_name = (symbol ? symbol : xstrdup("??"));
-
-        /* MODNAME */
-        aux->modname = read_string(&cur);
-
-        /* FINGERPRINT */
-        aux->fingerprint = read_string(&cur);
-
-        /* Skip the rest of the line. */
-        while (*cur && *cur++ != '\n')
-            continue;
+        VERB1 log("Failed to parse backtrace, considering it not duplicate: %s", error_message);
+        free(error_message);
+        return 0;
     }
 
-    btp_normalize_thread(thread);
-    btp_thread_remove_frames_below_n(thread, BACKTRACE_TRUNCATE_LENGTH);
+    struct sr_thread *thread2 = sr_stacktrace_find_crash_thread(bt2);
 
-    return thread;
-}
-
-static void free_core_backtrace(struct btp_thread *thread)
-{
-    if (thread)
-        btp_thread_free(thread);
-}
-
-static int core_backtrace_frame_compare(struct btp_frame *frame1, struct btp_frame *frame2)
-{
-    /* If both function names are known, compare them directly. */
-    if (frame1->function_name && frame2->function_name
-      && strcmp(frame1->function_name, "??") != 0
-      && strcmp(frame2->function_name, "??") != 0)
+    if (thread2 == NULL)
     {
-        return strcmp(frame1->function_name, frame2->function_name);
+        VERB1 log("Failed to get crash thread, considering it not duplicate");
+        result = 0;
+        goto end;
     }
 
-    struct frame_aux *aux1 = frame1->user_data;
-    struct frame_aux *aux2 = frame2->user_data;
+    int length2 = sr_thread_frame_count(thread2);
 
-    /* If build ids are equal, we can compare the offsets.
-     * Note that this may miss the case where the same function is called from
-     * other function in multiple places, which would pass if we were comparing
-     * the function names. */
-    if (aux1->build_id && aux2->build_id
-      && strcmp(aux1->build_id, aux2->build_id) == 0)
+    if (length2 <= 0)
     {
-        return (frame1->address != frame2->address);
-    }
-
-    /* Compare the fingerprints if present. */
-    if (aux1->fingerprint && aux2->fingerprint)
-    {
-        return strcmp(aux1->fingerprint, aux2->fingerprint);
+        VERB1 log("Core backtrace has zero frames, considering it not duplicate");
+        result = 0;
+        goto end;
     }
 
-    /* No match, assume the functions are different. */
-    return -1;
-}
+    /* This is an ugly workaround for https://github.com/abrt/btparser/issues/6 */
+    /*
+    int length1 = sr_core_thread_get_frame_count(thread1);
 
-static int core_backtrace_is_duplicate(struct btp_thread *bt1, const char *bt2_text)
-{
-    int result;
-    struct btp_thread *bt2 = load_core_backtrace(bt2_text);
-    if (bt2 == NULL)
+    if (length1 <= 2 || length2 <= 2)
     {
-        VERB1 log("Failed to parse backtrace, considering it not duplicate");
-        return 0;
+        VERB1 log("Backtraces too short, falling back on full comparison");
+        result = (sr_core_thread_cmp(thread1, thread2) == 0);
+        goto end;
     }
+    */
 
-    int distance = btp_thread_levenshtein_distance_custom(bt1, bt2, true, core_backtrace_frame_compare);
-    if (distance == -1)
-    {
-        result = 0;
-    }
-    else
-    {
-        VERB2 log("Distance between backtraces: %d", distance);
-        result = (distance <= BACKTRACE_DUP_THRESHOLD);
-    }
+    float distance = sr_distance(SR_DISTANCE_DAMERAU_LEVENSHTEIN, thread1, thread2);
+    VERB2 log("Distance between backtraces: %f", distance);
+    result = (distance <= BACKTRACE_DUP_THRESHOLD);
 
-    free_core_backtrace(bt2);
+end:
+    sr_stacktrace_free(bt2);
 
     return result;
 }
@@ -254,19 +152,30 @@ static void dup_uuid_fini(void)
 
 static void dup_corebt_init(const struct dump_dir *dd)
 {
-    char *corebt_text;
-
     if (corebt)
-        return; /* already checked */
-
-    corebt_text = dd_load_text_ext(dd, FILENAME_CORE_BACKTRACE,
-                            DD_FAIL_QUIETLY_ENOENT | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE
-    );
+        return; /* already loaded */
 
+    char *corebt_text = load_backtrace(dd);
     if (!corebt_text)
         return; /* no backtrace */
 
-    corebt = load_core_backtrace(corebt_text);
+    enum sr_report_type report_type = sr_abrt_type_from_analyzer(analyzer);
+    if (report_type == SR_REPORT_INVALID)
+    {
+        VERB1 log("Can't load stacktrace because of unsupported analyzer: %s",
+                  analyzer);
+        return;
+    }
+
+    /* sr_stacktrace_parse moves the pointer */
+    char *error_message;
+    corebt = sr_stacktrace_parse(report_type, corebt_text, &error_message);
+    if (!corebt)
+    {
+        VERB1 log("Failed to load core stacktrace: %s", error_message);
+        free(error_message);
+    }
+
     free(corebt_text);
 }
 
@@ -276,9 +185,8 @@ static int dup_corebt_compare(const struct dump_dir *dd)
         return 0;
 
     int isdup;
-    char *dd_corebt = dd_load_text_ext(dd, FILENAME_CORE_BACKTRACE,
-            DD_FAIL_QUIETLY_ENOENT | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);
 
+    char *dd_corebt = load_backtrace(dd);
     if (!dd_corebt)
         return 0;
 
@@ -293,7 +201,7 @@ static int dup_corebt_compare(const struct dump_dir *dd)
 
 static void dup_corebt_fini(void)
 {
-    free_core_backtrace(corebt);
+    sr_stacktrace_free(corebt);
     corebt = NULL;
 }
 
@@ -326,12 +234,15 @@ static int is_crash_a_dup(const char *dump_dir_name, void *param)
     struct dump_dir *dd = dd_opendir(dump_dir_name, DD_OPEN_READONLY);
     if (!dd)
         return 0; /* wtf? (error, but will be handled elsewhere later) */
-
+    free(analyzer);
+    analyzer = dd_load_text(dd, FILENAME_ANALYZER);
     dup_uuid_init(dd);
     dup_corebt_init(dd);
-
     dd_close(dd);
 
+    /* dump_dir_name can be relative */
+    dump_dir_name = realpath(dump_dir_name, NULL);
+
     DIR *dir = opendir(g_settings_dump_location);
     if (dir == NULL)
         goto end;
@@ -339,7 +250,7 @@ static int is_crash_a_dup(const char *dump_dir_name, void *param)
     /* Scan crash dumps looking for a dup */
     //TODO: explain why this is safe wrt concurrent runs
     struct dirent *dent;
-    while ((dent = readdir(dir)) != NULL)
+    while ((dent = readdir(dir)) != NULL && crash_dump_dup_name == NULL)
     {
         if (dot_or_dotdot(dent->d_name))
             continue; /* skip "." and ".." */
@@ -347,7 +258,20 @@ static int is_crash_a_dup(const char *dump_dir_name, void *param)
         if (ext && strcmp(ext, ".new") == 0)
             continue; /* skip anything named "<dirname>.new" */
 
-        char *dump_dir_name2 = concat_path_file(g_settings_dump_location, dent->d_name);
+        dd = NULL;
+
+        char *tmp_concat_path = concat_path_file(g_settings_dump_location, dent->d_name);
+
+        char *dump_dir_name2 = realpath(tmp_concat_path, NULL);
+        if (g_verbose > 1 && !dump_dir_name2)
+            perror_msg("realpath(%s)", tmp_concat_path);
+
+        free(tmp_concat_path);
+
+        if (!dump_dir_name2)
+            continue;
+
+        char *dd_uid = NULL, *dd_analyzer = NULL;
 
         if (strcmp(dump_dir_name, dump_dir_name2) == 0)
             goto next; /* we are never a dup of ourself */
@@ -357,29 +281,38 @@ static int is_crash_a_dup(const char *dump_dir_name, void *param)
             goto next;
 
         /* crashes of different users are not considered duplicates */
-        char *dd_uid = dd_load_text_ext(dd, FILENAME_UID, DD_FAIL_QUIETLY_ENOENT);
+        dd_uid = dd_load_text_ext(dd, FILENAME_UID, DD_FAIL_QUIETLY_ENOENT);
         if (strcmp(uid, dd_uid))
         {
-            dd_close(dd);
+            goto next;
+        }
+
+        /* different crash types are not duplicates */
+        dd_analyzer = dd_load_text_ext(dd, FILENAME_ANALYZER, DD_FAIL_QUIETLY_ENOENT);
+        if (strcmp(analyzer, dd_analyzer))
+        {
             goto next;
         }
 
         if (dup_uuid_compare(dd)
          || dup_corebt_compare(dd)
         ) {
-            dd_close(dd);
             crash_dump_dup_name = dump_dir_name2;
+            dump_dir_name2 = NULL;
             retval = 1; /* "run_event, please stop iterating" */
-            goto end;
+            /* sonce crash_dump_dup_name != NULL now, we exit the loop */
         }
-        dd_close(dd);
 
 next:
         free(dump_dir_name2);
+        dd_close(dd);
+        free(dd_uid);
+        free(dd_analyzer);
     }
     closedir(dir);
 
 end:
+    free((char*)dump_dir_name);
     return retval;
 }
 
diff --git a/src/include/libabrt.h b/src/include/libabrt.h
index ebd1b6e..bbbd27d 100644
--- a/src/include/libabrt.h
+++ b/src/include/libabrt.h
@@ -41,11 +41,10 @@ extern "C" {
 void check_free_space(unsigned setting_MaxCrashReportsSize, const char *dump_location);
 #define trim_problem_dirs abrt_trim_problem_dirs
 void trim_problem_dirs(const char *dirname, double cap_size, const char *exclude_path);
-#define exec_vp abrt_exec_vp
-char* exec_vp(char **args, uid_t uid, int redirect_stderr, int exec_timeout_sec, int *status);
 #define run_unstrip_n abrt_run_unstrip_n
 char *run_unstrip_n(const char *dump_dir_name, unsigned timeout_sec);
-
+#define get_backtrace abrt_get_backtrace
+char *get_backtrace(const char *dump_dir_name, unsigned timeout_sec, const char *debuginfo_dirs);
 
 #define g_settings_nMaxCrashReportsSize abrt_g_settings_nMaxCrashReportsSize
 extern unsigned int  g_settings_nMaxCrashReportsSize;
@@ -75,7 +74,7 @@ char *koops_extract_version(const char *line);
 #define kernel_tainted_short abrt_kernel_tainted_short
 char *kernel_tainted_short(const char *kernel_bt);
 #define koops_hash_str_ext abrt_koops_hash_str_ext
-int koops_hash_str_ext(char hash_str[SHA1_RESULT_LEN*2 + 1], const char *oops_buf, int frame_count, int only_reliable);
+int koops_hash_str_ext(char hash_str[SHA1_RESULT_LEN*2 + 1], const char *oops_buf, int frame_count, int duphash_flags);
 #define koops_hash_str abrt_koops_hash_str
 int koops_hash_str(char hash_str[SHA1_RESULT_LEN*2 + 1], const char *oops_buf);
 #define koops_extract_oopses abrt_koops_extract_oopses
diff --git a/src/lib/Makefile.am b/src/lib/Makefile.am
index 5ecb593..978761c 100644
--- a/src/lib/Makefile.am
+++ b/src/lib/Makefile.am
@@ -21,9 +21,11 @@ libabrt_la_CPPFLAGS = \
     -DEVENTS_DIR=\"$(EVENTS_DIR)\" \
     $(GLIB_CFLAGS) \
     $(LIBREPORT_CFLAGS) \
+    $(SATYR_CFLAGS) \
     -D_GNU_SOURCE
 libabrt_la_LDFLAGS = \
     -version-info 0:1:0
 libabrt_la_LIBADD = \
     $(GLIB_LIBS) \
-    $(LIBREPORT_LIBS)
+    $(LIBREPORT_LIBS) \
+    $(SATYR_LIBS)
diff --git a/src/lib/hooklib.c b/src/lib/hooklib.c
index 7800855..cee77e4 100644
--- a/src/lib/hooklib.c
+++ b/src/lib/hooklib.c
@@ -86,7 +86,7 @@ void trim_problem_dirs(const char *dirname, double cap_size, const char *exclude
  * @param[out] status See `man 2 wait` for status information.
  * @return Malloc'ed string
  */
-char* exec_vp(char **args, uid_t uid, int redirect_stderr, int exec_timeout_sec, int *status)
+static char* exec_vp(char **args, int redirect_stderr, unsigned exec_timeout_sec, int *status)
 {
     /* Nuke everything which may make setlocale() switch to non-POSIX locale:
      * we need to avoid having gdb output in some obscure language.
@@ -109,14 +109,12 @@ char* exec_vp(char **args, uid_t uid, int redirect_stderr, int exec_timeout_sec,
     };
 
     int flags = EXECFLG_INPUT_NUL | EXECFLG_OUTPUT | EXECFLG_SETSID | EXECFLG_QUIET;
-    if (uid != (uid_t)-1L)
-        flags |= EXECFLG_SETGUID;
     if (redirect_stderr)
         flags |= EXECFLG_ERR2OUT;
     VERB1 flags &= ~EXECFLG_QUIET;
 
     int pipeout[2];
-    pid_t child = fork_execv_on_steroids(flags, args, pipeout, (char**)env_vec, /*dir:*/ NULL, uid);
+    pid_t child = fork_execv_on_steroids(flags, args, pipeout, (char**)env_vec, /*dir:*/ NULL, /*uid(unused):*/ 0);
 
     /* We use this function to run gdb and unstrip. Bugs in gdb or corrupted
      * coredumps were observed to cause gdb to enter infinite loop.
@@ -250,3 +248,141 @@ char *run_unstrip_n(const char *dump_dir_name, unsigned timeout_sec)
 
     return strbuf_free_nobuf(buf_out);
 }
+
+char *get_backtrace(const char *dump_dir_name, unsigned timeout_sec, const char *debuginfo_dirs)
+{
+    struct dump_dir *dd = dd_opendir(dump_dir_name, /*flags:*/ 0);
+    if (!dd)
+        return NULL;
+    char *executable = dd_load_text(dd, FILENAME_EXECUTABLE);
+    dd_close(dd);
+
+    /* Let user know what's going on */
+    log(_("Generating backtrace"));
+
+    char *args[21];
+    args[0] = (char*)"gdb";
+    args[1] = (char*)"-batch";
+    args[2] = (char*)"-ex";
+    struct strbuf *set_debug_file_directory = strbuf_new();
+    if(debuginfo_dirs == NULL)
+    {
+        // set non-existent debug file directory to prevent resolving
+        // function names - we need offsets for core backtrace.
+        strbuf_append_str(set_debug_file_directory, "set debug-file-directory /");
+    }
+    else
+    {
+        strbuf_append_str(set_debug_file_directory, "set debug-file-directory /usr/lib/debug");
+        const char *p = debuginfo_dirs;
+        while (1)
+        {
+            while (*p == ':')
+                p++;
+            if (*p == '\0')
+                break;
+            const char *colon_or_nul = strchrnul(p, ':');
+            strbuf_append_strf(set_debug_file_directory, ":%.*s/usr/lib/debug", (int)(colon_or_nul - p), p);
+            p = colon_or_nul;
+        }
+    }
+    args[3] = strbuf_free_nobuf(set_debug_file_directory);
+
+    /* "file BINARY_FILE" is needed, without it gdb cannot properly
+     * unwind the stack. Currently the unwind information is located
+     * in .eh_frame which is stored only in binary, not in coredump
+     * or debuginfo.
+     *
+     * Fedora GDB does not strictly need it, it will find the binary
+     * by its build-id.  But for binaries either without build-id
+     * (= built on non-Fedora GCC) or which do not have
+     * their debuginfo rpm installed gdb would not find BINARY_FILE
+     * so it is still makes sense to supply "file BINARY_FILE".
+     *
+     * Unfortunately, "file BINARY_FILE" doesn't work well if BINARY_FILE
+     * was deleted (as often happens during system updates):
+     * gdb uses specified BINARY_FILE
+     * even if it is completely unrelated to the coredump.
+     * See https://bugzilla.redhat.com/show_bug.cgi?id=525721
+     *
+     * TODO: check mtimes on COREFILE and BINARY_FILE and not supply
+     * BINARY_FILE if it is newer (to at least avoid gdb complaining).
+     */
+    args[4] = (char*)"-ex";
+    args[5] = xasprintf("file %s", executable);
+    free(executable);
+
+    args[6] = (char*)"-ex";
+    args[7] = xasprintf("core-file %s/"FILENAME_COREDUMP, dump_dir_name);
+
+    args[8] = (char*)"-ex";
+    /*args[9] = ... see below */
+    args[10] = (char*)"-ex";
+    args[11] = (char*)"info sharedlib";
+    /* glibc's abort() stores its message in __abort_msg variable */
+    args[12] = (char*)"-ex";
+    args[13] = (char*)"print (char*)__abort_msg";
+    args[14] = (char*)"-ex";
+    args[15] = (char*)"print (char*)__glib_assert_msg";
+    args[16] = (char*)"-ex";
+    args[17] = (char*)"info all-registers";
+    args[18] = (char*)"-ex";
+    args[19] = (char*)"disassemble";
+    args[20] = NULL;
+
+    /* Get the backtrace, but try to cap its size */
+    /* Limit bt depth. With no limit, gdb sometimes OOMs the machine */
+    unsigned bt_depth = 1024;
+    const char *thread_apply_all = "thread apply all";
+    const char *full = " full";
+    char *bt = NULL;
+    while (1)
+    {
+        args[9] = xasprintf("%s backtrace %u%s", thread_apply_all, bt_depth, full);
+        bt = exec_vp(args, /*redirect_stderr:*/ 1, timeout_sec, NULL);
+        free(args[9]);
+        if ((bt && strnlen(bt, 256*1024) < 256*1024) || bt_depth <= 32)
+        {
+            break;
+        }
+
+        bt_depth /= 2;
+        if (bt)
+            log("Backtrace is too big (%u bytes), reducing depth to %u",
+                        (unsigned)strlen(bt), bt_depth);
+        else
+            /* (NB: in fact, current impl. of exec_vp() never returns NULL) */
+            log("Failed to generate backtrace, reducing depth to %u",
+                        bt_depth);
+        free(bt);
+
+        /* Replace -ex disassemble (which disasms entire function $pc points to)
+         * to a version which analyzes limited, small patch of code around $pc.
+         * (Users reported a case where bare "disassemble" attempted to process
+         * entire .bss).
+         * TODO: what if "$pc-N" underflows? in my test, this happens:
+         * Dump of assembler code from 0xfffffffffffffff0 to 0x30:
+         * End of assembler dump.
+         * (IOW: "empty" dump)
+         */
+        args[19] = (char*)"disassemble $pc-20, $pc+64";
+
+        if (bt_depth <= 64 && thread_apply_all[0] != '\0')
+        {
+            /* This program likely has gazillion threads, dont try to bt them all */
+            bt_depth = 128;
+            thread_apply_all = "";
+        }
+        if (bt_depth <= 64 && full[0] != '\0')
+        {
+            /* Looks like there are gigantic local structures or arrays, disable "full" bt */
+            bt_depth = 128;
+            full = "";
+        }
+    }
+
+    free(args[3]);
+    free(args[5]);
+    free(args[7]);
+    return bt;
+}
diff --git a/src/lib/kernel.c b/src/lib/kernel.c
index ae225c6..2f782d1 100644
--- a/src/lib/kernel.c
+++ b/src/lib/kernel.c
@@ -16,6 +16,8 @@
     with this program; if not, write to the Free Software Foundation, Inc.,
     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
+#include <satyr/stacktrace.h>
+#include <satyr/thread.h>
 
 #include "libabrt.h"
 
@@ -366,140 +368,58 @@ next_line:
     free(lines_info);
 }
 
-int koops_hash_str_ext(char hash_str[SHA1_RESULT_LEN*2 + 1], const char *oops_buf, int frame_count, int only_reliable)
+int koops_hash_str_ext(char result[SHA1_RESULT_LEN*2 + 1], const char *oops_buf, int frame_count, int duphash_flags)
 {
-    struct strbuf *kernel_bt = strbuf_new();
-
-    // Example of call trace part of oops:
-    // Call Trace:
-    // [<f88e11c7>] ? radeon_cp_resume+0x7d/0xbc [radeon]
-    // [<f88745f8>] ? drm_ioctl+0x1b0/0x225 [drm]
-    // [<f88e114a>] ? radeon_cp_resume+0x0/0xbc [radeon]
-    // [<c049b1c0>] ? vfs_ioctl+0x50/0x69
-    // [<c049b414>] ? do_vfs_ioctl+0x23b/0x247
-    // [<c0460a56>] ? audit_syscall_entry+0xf9/0x123
-    // [<c049b460>] ? sys_ioctl+0x40/0x5c
-    // [<c0403c76>] ? syscall_call+0x7/0xb
-    // Code:...  <======== we should ignore everything which isn't call trace
-    // RIP  ...
-    char *call_trace = strcasestr(oops_buf, "Call Trace:"); /* yes, it must be case-insensitive */
-    if (call_trace)
-    {
-        /* Different architectures have different case
-         * and different kind/amount of whitespace after ":" -
-         * don't assume there is a single "\n"!
-         */
-        call_trace += sizeof("Call Trace:")-1;
-        call_trace = skip_whitespace(call_trace);
-        int i = 0;
-        for (;;)
-        {
-            char *end_line = strchr(call_trace, '\n');
-            if (!end_line)
-                break;
-            char *line = xstrndup(call_trace, end_line - call_trace);
-
-            /* Skip whitespace and "<IRQ>" / "<EOI>" markers */
-            char *p = line;
-            for (;;)
-            {
-                p = skip_whitespace(p);
-                if (prefixcmp(p, "<IRQ>") == 0)
-                {
-                    p += strlen("<IRQ>");
-                    continue;
-                }
-                if (prefixcmp(p, "<EOI>") == 0)
-                {
-                    p += strlen("<EOI>");
-                    continue;
-                }
-                /* Didn't see it in practice,
-                 * but code inspection in arch/x86/kernel/dumpstack_64.c
-                 * tells me these strings can be there as well:
-                 */
-                if (prefixcmp(p, "<EOE>") == 0)
-                {
-                    p += strlen("<EOE>");
-                    continue;
-                }
-                if (prefixcmp(p, "<<EOE>>") == 0)
-                {
-                    p += strlen("<<EOE>>");
-                    continue;
-                }
-                break;
-            }
+    char *hash_str = NULL, *error = NULL;
+    int bad = 0;
 
-            char *end_mem_block = strchr(p, ' ');
-            if (!end_mem_block)
-                goto done; /* no memblock, we are done */
-            if (p[0] != '[' || p[1] != '<' || end_mem_block[-2] != '>' || end_mem_block[-1] != ']')
-                goto done; /* no memblock, we are done */
-
-            /* skip symbols prefixed with "?" */
-            end_mem_block = skip_whitespace(end_mem_block);
-            if (only_reliable && end_mem_block && *end_mem_block == '?')
-                goto skip_line;
-            /* strip out "+off/len" */
-            p = strchrnul(end_mem_block, '+');
-            /* append "func_name\n" */
-            strbuf_append_strf(kernel_bt, "%.*s\n", (int)(p - end_mem_block), end_mem_block);
-            if (frame_count > 0 && i == frame_count)
-            {
- done:
-                free(line);
-                break;
-            }
-            ++i;
- skip_line:
-            free(line);
-            call_trace = end_line + 1;
-        }
-        goto gen_hash;
+    struct sr_stacktrace *stacktrace = sr_stacktrace_parse(SR_REPORT_KERNELOOPS,
+                                                           oops_buf, &error);
+    if (!stacktrace)
+    {
+        VERB3 log("Failed to parse koops: %s", error);
+        free(error);
+        bad = 1;
+        goto end;
     }
 
-    /* Special-case: if the first line is of form:
-     * WARNING: at net/wireless/core.c:614 wdev_cleanup_work+0xe9/0x120 [cfg80211]() (Not tainted)
-     * then hash only "file:line func+ofs/len" part.
-     */
-    if (strncmp(oops_buf, "WARNING: at ", sizeof("WARNING: at ")-1) == 0)
+    struct sr_thread *thread = sr_stacktrace_find_crash_thread(stacktrace);
+    if (!thread)
     {
-        const char *p = oops_buf + sizeof("WARNING: at ")-1;
-        p = strchr(p, ' '); /* skip filename:NNN */
-        if (p)
-        {
-            p = strchrnul(p + 1, ' '); /* skip function_name+0xNN/0xNNN */
-            oops_buf += sizeof("WARNING: at ")-1;
-            while (oops_buf < p)
-                strbuf_append_char(kernel_bt, *oops_buf++);
-        }
+        VERB3 log("Failed to find crash thread");
+        bad = 1;
+        goto end;
     }
 
- gen_hash: ;
-    VERB3 log("bt to hash: '%s'", kernel_bt->buf);
-
-    /* If we failed to find and process bt, we may end up hashing "".
-     * Not good. Let user know it via return value.
-     */
-    int bad = (kernel_bt->len == 0);
-
-    char hash_bytes[SHA1_RESULT_LEN];
-    sha1_ctx_t sha1ctx;
-    sha1_begin(&sha1ctx);
-    sha1_hash(&sha1ctx, kernel_bt->buf, kernel_bt->len);
-    sha1_end(&sha1ctx, hash_bytes);
-    strbuf_free(kernel_bt);
+    if (g_verbose >= 3)
+    {
+        hash_str = sr_thread_get_duphash(thread, frame_count, NULL,
+                                         duphash_flags|SR_DUPHASH_NOHASH);
+        if (hash_str)
+            log("Generating duphash: %s", hash_str);
+        free(hash_str);
+    }
 
-    bin2hex(hash_str, hash_bytes, SHA1_RESULT_LEN)[0] = '\0';
-    VERB3 log("hash: %s", hash_str);
+    hash_str = sr_thread_get_duphash(thread, frame_count, NULL, duphash_flags);
+    if (hash_str)
+    {
+        strncpy(result, hash_str, SHA1_RESULT_LEN*2);
+        result[SHA1_RESULT_LEN*2] = '\0';
+        free(hash_str);
+    }
+    else
+        bad = 1;
 
+end:
+    sr_stacktrace_free(stacktrace);
     return bad;
 }
 
 int koops_hash_str(char hash_str[SHA1_RESULT_LEN*2 + 1], const char *oops_buf)
 {
-    return koops_hash_str_ext(hash_str, oops_buf, /*frame count*/5, /*only reliable*/1);
+    const int frame_count = 5;
+    const int duphash_flags = SR_DUPHASH_NONORMALIZE|SR_DUPHASH_KOOPS_COMPAT;
+    return koops_hash_str_ext(hash_str, oops_buf, frame_count, duphash_flags);
 }
 
 char *koops_extract_version(const char *linepointer)
diff --git a/src/plugins/Makefile.am b/src/plugins/Makefile.am
index b9a3cf1..ad843a9 100644
--- a/src/plugins/Makefile.am
+++ b/src/plugins/Makefile.am
@@ -154,10 +154,12 @@ abrt_action_generate_core_backtrace_CPPFLAGS = \
     -DLOCALSTATEDIR='"$(localstatedir)"' \
     $(GLIB_CFLAGS) \
     $(LIBREPORT_CFLAGS) \
+    $(SATYR_CFLAGS) \
     -D_GNU_SOURCE \
     -Wall -Wwrite-strings -Werror
 abrt_action_generate_core_backtrace_LDADD = \
     $(LIBREPORT_LIBS) \
+    $(SATYR_LIBS) \
     ../lib/libabrt.la
 
 if ENABLE_DISASSEMBLY
@@ -181,7 +183,7 @@ abrt_action_analyze_backtrace_CPPFLAGS = \
     -Wall -Wwrite-strings -Werror
 abrt_action_analyze_backtrace_LDADD = \
     $(LIBREPORT_LIBS) \
-    $(BTPARSER_LIBS)
+    $(SATYR_LIBS)
 
 # SUID application, building with full relro and PIE
 # for increased security.
@@ -214,7 +216,7 @@ abrt_dedup_client_SOURCES = \
      -Wall -Wwrite-strings -Werror
  abrt_dedup_client_LDADD = \
      $(LIBREPORT_LIBS) \
-     $(BTPARSER_LIBS) \
+     $(SATYR_LIBS) \
      $(NSS_LIBS)
 
 DEFS = -DLOCALEDIR=\"$(localedir)\" @DEFS@
diff --git a/src/plugins/abrt-action-analyze-backtrace.c b/src/plugins/abrt-action-analyze-backtrace.c
index 3333c7e..a88bce3 100644
--- a/src/plugins/abrt-action-analyze-backtrace.c
+++ b/src/plugins/abrt-action-analyze-backtrace.c
@@ -15,26 +15,16 @@
     with this program; if not, write to the Free Software Foundation, Inc.,
     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
-#include <btparser/backtrace.h>
-#include <btparser/frame.h>
-#include <btparser/location.h>
+#include <satyr/location.h>
+#include <satyr/thread.h>
+#include <satyr/gdb/frame.h>
+#include <satyr/gdb/stacktrace.h>
+
 #include "libabrt.h"
 
 static const char *dump_dir_name = ".";
 
 
-static void create_hash(char hash_str[SHA1_RESULT_LEN*2 + 1], const char *pInput)
-{
-    char hash_bytes[SHA1_RESULT_LEN];
-    sha1_ctx_t sha1ctx;
-    sha1_begin(&sha1ctx);
-    sha1_hash(&sha1ctx, pInput, strlen(pInput));
-    sha1_end(&sha1ctx, hash_bytes);
-
-    bin2hex(hash_str, hash_bytes, SHA1_RESULT_LEN)[0] = '\0';
-    //log("hash:%s str:'%s'", hash_str, pInput);
-}
-
 int main(int argc, char **argv)
 {
     /* I18n */
@@ -83,10 +73,10 @@ int main(int argc, char **argv)
     }
 
     /* Compute backtrace hash */
-    struct btp_location location;
-    btp_location_init(&location);
+    struct sr_location location;
+    sr_location_init(&location);
     const char *backtrace_str_ptr = backtrace_str;
-    struct btp_backtrace *backtrace = btp_backtrace_parse(&backtrace_str_ptr, &location);
+    struct sr_gdb_stacktrace *backtrace = sr_gdb_stacktrace_parse(&backtrace_str_ptr, &location);
     free(backtrace_str);
 
     /* Store backtrace hash */
@@ -109,7 +99,7 @@ int main(int argc, char **argv)
 
         VERB3 log("Generating duphash: %s", emptybt->buf);
         char hash_str[SHA1_RESULT_LEN*2 + 1];
-        create_hash(hash_str, emptybt->buf);
+        str_to_sha1str(hash_str, emptybt->buf);
 
         dd_save_text(dd, FILENAME_DUPHASH, hash_str);
         /*
@@ -132,21 +122,31 @@ int main(int argc, char **argv)
     }
 
     /* Compute duplication hash. */
-    char *str_hash_core = btp_backtrace_get_duplication_hash(backtrace);
-    struct strbuf *str_hash = strbuf_new();
-    strbuf_append_str(str_hash, component);
-    strbuf_append_str(str_hash, str_hash_core);
+    struct sr_thread *crash_thread =
+        (struct sr_thread *)sr_gdb_stacktrace_find_crash_thread(backtrace);
 
-    VERB3 log("Generating duphash: %s", str_hash->buf);
-    char hash_str[SHA1_RESULT_LEN*2 + 1];
-    create_hash(hash_str, str_hash->buf);
+    if (crash_thread)
+    {
+        char *hash_str;
 
-    dd_save_text(dd, FILENAME_DUPHASH, hash_str);
-    strbuf_free(str_hash);
-    free(str_hash_core);
+        if (g_verbose >= 3)
+        {
+            hash_str = sr_thread_get_duphash(crash_thread, 3, component,
+                                             SR_DUPHASH_NOHASH);
+            log("Generating duphash: %s", hash_str);
+            free(hash_str);
+        }
+
+        hash_str = sr_thread_get_duphash(crash_thread, 3, component,
+                                         SR_DUPHASH_NORMAL);
+        dd_save_text(dd, FILENAME_DUPHASH, hash_str);
+        free(hash_str);
+    }
+    else
+        log(_("Crash thread not found"));
 
     /* Compute the backtrace rating. */
-    float quality = btp_backtrace_quality_complex(backtrace);
+    float quality = sr_gdb_stacktrace_quality_complex(backtrace);
     const char *rating;
     if (quality < 0.6f)
         rating = "0";
@@ -161,7 +161,7 @@ int main(int argc, char **argv)
     dd_save_text(dd, FILENAME_RATING, rating);
 
     /* Get the function name from the crash frame. */
-    struct btp_frame *crash_frame = btp_backtrace_get_crash_frame(backtrace);
+    struct sr_gdb_frame *crash_frame = sr_gdb_stacktrace_get_crash_frame(backtrace);
     if (crash_frame)
     {
         if (crash_frame->function_name &&
@@ -169,9 +169,9 @@ int main(int argc, char **argv)
         {
             dd_save_text(dd, FILENAME_CRASH_FUNCTION, crash_frame->function_name);
         }
-        btp_frame_free(crash_frame);
+        sr_gdb_frame_free(crash_frame);
     }
-    btp_backtrace_free(backtrace);
+    sr_gdb_stacktrace_free(backtrace);
     dd_close(dd);
     free(component);
     return 0;
diff --git a/src/plugins/abrt-action-analyze-c.c b/src/plugins/abrt-action-analyze-c.c
index 28ddf4a..880c5c6 100644
--- a/src/plugins/abrt-action-analyze-c.c
+++ b/src/plugins/abrt-action-analyze-c.c
@@ -18,18 +18,6 @@
 */
 #include "libabrt.h"
 
-static void create_hash(char hash_str[SHA1_RESULT_LEN*2 + 1], const char *pInput)
-{
-    char hash_bytes[SHA1_RESULT_LEN];
-    sha1_ctx_t sha1ctx;
-    sha1_begin(&sha1ctx);
-    sha1_hash(&sha1ctx, pInput, strlen(pInput));
-    sha1_end(&sha1ctx, hash_bytes);
-
-    bin2hex(hash_str, hash_bytes, SHA1_RESULT_LEN)[0] = '\0';
-    //log("hash:%s str:'%s'", hash_str, pInput);
-}
-
 static void trim_unstrip_output(char *result, const char *unstrip_n_output)
 {
     // lines look like this:
@@ -144,7 +132,7 @@ int main(int argc, char **argv)
     /*free(unstrip_n_output);*/
 
     char hash_str[SHA1_RESULT_LEN*2 + 1];
-    create_hash(hash_str, string_to_hash);
+    str_to_sha1str(hash_str, string_to_hash);
 
     dd_save_text(dd, FILENAME_UUID, hash_str);
     dd_close(dd);
diff --git a/src/plugins/abrt-action-analyze-python.c b/src/plugins/abrt-action-analyze-python.c
index aeab349..5ec6468 100644
--- a/src/plugins/abrt-action-analyze-python.c
+++ b/src/plugins/abrt-action-analyze-python.c
@@ -59,16 +59,11 @@ int main(int argc, char **argv)
     /* Hash 1st line of backtrace and save it as UUID and DUPHASH */
     /* "example.py:1:<module>:ZeroDivisionError: integer division or modulo by zero" */
 
-    char hash_bytes[SHA1_RESULT_LEN];
-    sha1_ctx_t sha1ctx;
-    sha1_begin(&sha1ctx);
-    const char *bt_end = strchrnul(bt, '\n');
-    sha1_hash(&sha1ctx, bt, bt_end - bt);
-    sha1_end(&sha1ctx, hash_bytes);
-    free(bt);
-
+    char *bt_end = strchrnul(bt, '\n');
+    *bt_end = '\0';
     char hash_str[SHA1_RESULT_LEN*2 + 1];
-    bin2hex(hash_str, hash_bytes, SHA1_RESULT_LEN)[0] = '\0';
+    str_to_sha1str(hash_str, bt);
+    free(bt);
 
     dd_save_text(dd, FILENAME_UUID, hash_str);
     dd_save_text(dd, FILENAME_DUPHASH, hash_str);
diff --git a/src/plugins/abrt-action-generate-backtrace.c b/src/plugins/abrt-action-generate-backtrace.c
index 71be7d1..0c3ff88 100644
--- a/src/plugins/abrt-action-generate-backtrace.c
+++ b/src/plugins/abrt-action-generate-backtrace.c
@@ -23,128 +23,6 @@ static const char *dump_dir_name = ".";
 /* 60 seconds was too limiting on slow machines */
 static int exec_timeout_sec = 240;
 
-
-static char *get_backtrace(struct dump_dir *dd, const char *debuginfo_dirs)
-{
-    char *uid_str = dd_load_text_ext(dd, FILENAME_UID, DD_FAIL_QUIETLY_ENOENT | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);
-    uid_t uid = -1L;
-    if (uid_str)
-    {
-        uid = xatoi_positive(uid_str);
-        free(uid_str);
-        if (uid == geteuid())
-        {
-            uid = -1L; /* no need to setuid/gid if we are already under right uid */
-        }
-    }
-    char *executable = dd_load_text(dd, FILENAME_EXECUTABLE);
-    dd_close(dd);
-
-    /* Let user know what's going on */
-    log(_("Generating backtrace"));
-
-    char *args[21];
-    args[0] = (char*)"gdb";
-    args[1] = (char*)"-batch";
-
-    // when/if gdb supports "set debug-file-directory DIR1:DIR2":
-    // (https://bugzilla.redhat.com/show_bug.cgi?id=528668):
-    args[2] = (char*)"-ex";
-    struct strbuf *set_debug_file_directory = strbuf_new();
-    strbuf_append_str(set_debug_file_directory, "set debug-file-directory /usr/lib/debug");
-    const char *p = debuginfo_dirs;
-    while (1)
-    {
-        while (*p == ':')
-            p++;
-        if (*p == '\0')
-            break;
-        const char *colon_or_nul = strchrnul(p, ':');
-        strbuf_append_strf(set_debug_file_directory, ":%.*s/usr/lib/debug", (int)(colon_or_nul - p), p);
-        p = colon_or_nul;
-    }
-    args[3] = strbuf_free_nobuf(set_debug_file_directory);
-
-    /* "file BINARY_FILE" is needed, without it gdb cannot properly
-     * unwind the stack. Currently the unwind information is located
-     * in .eh_frame which is stored only in binary, not in coredump
-     * or debuginfo.
-     *
-     * Fedora GDB does not strictly need it, it will find the binary
-     * by its build-id.  But for binaries either without build-id
-     * (= built on non-Fedora GCC) or which do not have
-     * their debuginfo rpm installed gdb would not find BINARY_FILE
-     * so it is still makes sense to supply "file BINARY_FILE".
-     *
-     * Unfortunately, "file BINARY_FILE" doesn't work well if BINARY_FILE
-     * was deleted (as often happens during system updates):
-     * gdb uses specified BINARY_FILE
-     * even if it is completely unrelated to the coredump.
-     * See https://bugzilla.redhat.com/show_bug.cgi?id=525721
-     *
-     * TODO: check mtimes on COREFILE and BINARY_FILE and not supply
-     * BINARY_FILE if it is newer (to at least avoid gdb complaining).
-     */
-    args[4] = (char*)"-ex";
-    args[5] = xasprintf("file %s", executable);
-    free(executable);
-
-    args[6] = (char*)"-ex";
-    args[7] = xasprintf("core-file %s/"FILENAME_COREDUMP, dump_dir_name);
-
-    args[8] = (char*)"-ex";
-    /*args[9] = ... see below */
-    args[10] = (char*)"-ex";
-    args[11] = (char*)"info sharedlib";
-    /* glibc's abort() stores its message in __abort_msg variable */
-    args[12] = (char*)"-ex";
-    args[13] = (char*)"print (char*)__abort_msg";
-    args[14] = (char*)"-ex";
-    args[15] = (char*)"print (char*)__glib_assert_msg";
-    args[16] = (char*)"-ex";
-    args[17] = (char*)"info registers";
-    args[18] = (char*)"-ex";
-    args[19] = (char*)"disassemble";
-    args[20] = NULL;
-
-    /* Get the backtrace, but try to cap its size */
-    /* Limit bt depth. With no limit, gdb sometimes OOMs the machine */
-    unsigned bt_depth = 2048;
-    const char *thread_apply_all = "thread apply all";
-    const char *full = " full";
-    char *bt = NULL;
-    while (1)
-    {
-        args[9] = xasprintf("%s backtrace %u%s", thread_apply_all, bt_depth, full);
-        bt = exec_vp(args, uid, /*redirect_stderr:*/ 1, exec_timeout_sec, NULL);
-        free(args[9]);
-        if ((bt && strnlen(bt, 256*1024) < 256*1024) || bt_depth <= 32)
-        {
-            break;
-        }
-
-        free(bt);
-        bt_depth /= 2;
-        if (bt_depth <= 64 && thread_apply_all[0] != '\0')
-        {
-            /* This program likely has gazillion threads, dont try to bt them all */
-            bt_depth = 256;
-            thread_apply_all = "";
-        }
-        if (bt_depth <= 64 && full[0] != '\0')
-        {
-            /* Looks like there are gigantic local structures or arrays, disable "full" bt */
-            bt_depth = 256;
-            full = "";
-        }
-    }
-
-    free(args[3]);
-    free(args[5]);
-    free(args[7]);
-    return bt;
-}
-
 int main(int argc, char **argv)
 {
     /* I18n */
@@ -198,13 +76,10 @@ int main(int argc, char **argv)
     if (i_opt)
         debuginfo_dirs = xasprintf("%s:%s", debuginfo_location, i_opt);
 
-    struct dump_dir *dd = dd_opendir(dump_dir_name, /*flags:*/ 0);
-    if (!dd)
-        return 1;
-
     /* Create gdb backtrace */
     /* NB: get_backtrace() closes dd */
-    char *backtrace = get_backtrace(dd, (debuginfo_dirs) ? debuginfo_dirs : debuginfo_location);
+    char *backtrace = get_backtrace(dump_dir_name, exec_timeout_sec,
+            (debuginfo_dirs) ? debuginfo_dirs : debuginfo_location);
     free(debuginfo_location);
     if (!backtrace)
     {
@@ -216,9 +91,10 @@ int main(int argc, char **argv)
 
     /* Store gdb backtrace */
 
-    dd = dd_opendir(dump_dir_name, /*flags:*/ 0);
+    struct dump_dir *dd = dd_opendir(dump_dir_name, /*flags:*/ 0);
     if (!dd)
         return 1;
+
     dd_save_text(dd, FILENAME_BACKTRACE, backtrace);
     dd_close(dd);
 
diff --git a/src/plugins/abrt-action-generate-core-backtrace.c b/src/plugins/abrt-action-generate-core-backtrace.c
index f6640b3..00d66e6 100644
--- a/src/plugins/abrt-action-generate-core-backtrace.c
+++ b/src/plugins/abrt-action-generate-core-backtrace.c
@@ -16,862 +16,10 @@
     with this program; if not, write to the Free Software Foundation, Inc.,
     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
-#include "libabrt.h"
-
-#ifdef ENABLE_DISASSEMBLY
-#include <libelf.h>
-#include <gelf.h>
-#include <elfutils/libdw.h>
-#include <dwarf.h>
-
-#include <bfd.h>
-#include <dis-asm.h>
-#endif /* ENABLE_DISASSEMBLY */
-
-struct backtrace_entry {
-    uintptr_t address;
-    char *build_id;
-    uintptr_t build_id_offset;
-    char *symbol;
-    char *modname;
-    char *filename;
-    char *fingerprint;
-    uintptr_t function_initial_loc;
-    uintptr_t function_length;
-};
-
-#define OR_UNKNOWN(s) ((s) ? (s) : "-")
-
-static char *backtrace_format(GList *backtrace)
-{
-    struct strbuf *strbuf = strbuf_new();
-    struct backtrace_entry *entry;
-
-    while (backtrace != NULL)
-    {
-        entry = backtrace->data;
-
-        /* BUILD_ID OFFSET SYMBOL MODNAME FINGERPRINT */
-        strbuf_append_strf(strbuf, "%s 0x%x %s %s %s\n",
-                    OR_UNKNOWN(entry->build_id),
-                    entry->build_id_offset,
-                    OR_UNKNOWN(entry->symbol),
-                    OR_UNKNOWN(entry->modname),
-                    OR_UNKNOWN(entry->fingerprint));
-
-        backtrace = g_list_next(backtrace);
-    }
-
-    return strbuf_free_nobuf(strbuf);
-}
-
-static void backtrace_add_build_id(GList *backtrace, uintmax_t start, uintmax_t length,
-            const char *build_id, unsigned build_id_len, const char *modname, unsigned modname_len,
-            const char *filename, unsigned filename_len)
-{
-    struct backtrace_entry *entry;
-
-    while (backtrace != NULL)
-    {
-        entry = backtrace->data;
-        if (start <= entry->address && entry->address <= start+length)
-        {
-            /* NOTE: we could get by with just one copy of the string, but that
-             * would mean more bookkeeping for us ... */
-            entry->build_id = xstrndup(build_id, build_id_len);
-            entry->build_id_offset = entry->address - start;
-            entry->modname = xstrndup(modname, modname_len);
-            entry->filename = xstrndup(filename, filename_len);
-        }
-
-        backtrace = g_list_next(backtrace);
-    }
-}
-
-static void assign_build_ids(GList *backtrace, const char *dump_dir_name)
-{
-    /* Run eu-unstrip -n to obtain the ids. This should be rewritten to read
-     * them directly from the core. */
-    char *unstrip_output = run_unstrip_n(dump_dir_name, /*timeout_sec:*/ 30);
-    if (unstrip_output == NULL)
-        error_msg_and_die("Running eu-unstrip failed");
-
-    /* Get the executable name -- unstrip doesn't know it. */
-    struct dump_dir *dd = dd_opendir(dump_dir_name, DD_OPEN_READONLY);
-    if (!dd)
-        xfunc_die(); /* dd_opendir already printed error msg */
-    char *executable = dd_load_text(dd, FILENAME_EXECUTABLE);
-    dd_close(dd);
-
-    const char *cur = unstrip_output;
-
-    uintmax_t start;
-    uintmax_t length;
-    const char *build_id;
-    unsigned build_id_len;
-    const char *modname;
-    unsigned modname_len;
-    const char *filename;
-    unsigned filename_len;
-
-    int ret;
-    int chars_read;
-
-    while (*cur)
-    {
-        /* beginning of the line */
-
-        /* START+SIZE */
-        ret = sscanf(cur, "0x%jx+0x%jx %n", &start, &length, &chars_read);
-        if (ret < 2)
-        {
-            goto eat_line;
-        }
-        cur += chars_read;
-
-        /* BUILDID */
-        build_id = cur;
-        while (isxdigit(*cur))
-        {
-            cur++;
-        }
-        build_id_len = cur-build_id;
-
-        /* there may be @ADDR after the ID */
-        cur = skip_non_whitespace(cur);
-        cur = skip_whitespace(cur);
-
-        /* FILE */
-        filename = cur;
-        cur = skip_non_whitespace(cur);
-        filename_len = cur-filename;
-        cur = skip_whitespace(cur);
-
-        /* DEBUGFILE */
-        cur = skip_non_whitespace(cur);
-        cur = skip_whitespace(cur);
-
-        /* MODULENAME */
-        modname = cur;
-        cur = skip_non_whitespace(cur);
-        modname_len = cur-modname;
-
-        /* Use real executable file name instead of "-". */
-        if (modname_len == 5 && strncmp(modname, "[exe]", 5) == 0)
-        {
-            filename = executable;
-            filename_len = strlen(executable);
-        }
-
-        backtrace_add_build_id(backtrace, start, length,
-                    build_id, build_id_len, modname, modname_len,
-                    filename, filename_len);
-
-eat_line:
-        while (*cur && *cur++ != '\n')
-            continue;
-    }
-
-    free(executable);
-    free(unstrip_output);
-}
-
-static GList *extract_addresses(const char *str)
-{
-    const char *cur = str;
-
-    unsigned frame_number;
-    unsigned next_frame = 0;
-    uintmax_t address;
-
-    int ret;
-    int chars_read;
-
-    struct backtrace_entry *entry;
-    GList *backtrace = NULL;
-
-    while (*cur)
-    {
-        /* check whether current line describes frame and if we haven't seen it
-         * already (gdb prints the first one on start) */
-        ret = sscanf(cur, "#%u 0x%jx in %n", &frame_number, &address, &chars_read);
-        if (ret < 2 || frame_number != next_frame)
-        {
-            goto eat_line;
-        }
-        next_frame++;
-        cur += chars_read;
-
-        /* is symbol available? */
-        const char *sym;
-        if (*cur && *cur != '?')
-        {
-            sym = cur;
-            cur = skip_non_whitespace(cur);
-
-            /* Ignore anything below __libc_start_main. */
-            if (strncmp("__libc_start_main", sym, 17) == 0)
-            {
-                break;
-            }
-        }
-        else
-        {
-            sym = NULL;
-        }
-
-        entry = xzalloc(sizeof(*entry));
-        entry->address = (uintptr_t)address;
-        entry->symbol = (sym ? xstrndup(sym, cur-sym) : NULL);
-        backtrace = g_list_append(backtrace, entry);
-
-eat_line:
-        while (*cur && *cur++ != '\n')
-            continue;
-    }
-
-    return backtrace;
-}
-
-/* mostly copypasted from abrt-action-generate-backtrace */
-static char *get_gdb_output(const char *dump_dir_name)
-{
-    struct dump_dir *dd = dd_opendir(dump_dir_name, /*flags:*/ 0);
-    if (!dd)
-        return NULL;
-
-    char *uid_str = dd_load_text_ext(dd, FILENAME_UID, DD_FAIL_QUIETLY_ENOENT | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE);
-    uid_t uid = -1L;
-    if (uid_str)
-    {
-        uid = xatoi_positive(uid_str);
-        free(uid_str);
-        if (uid == geteuid())
-        {
-            uid = -1L; /* no need to setuid/gid if we are already under right uid */
-        }
-    }
-    char *executable = dd_load_text(dd, FILENAME_EXECUTABLE);
-    dd_close(dd);
-
-    char *args[11];
-    args[0] = (char*)"gdb";
-    args[1] = (char*)"-batch";
-
-    /* NOTE: We used to use additional dirs here, but we don't need them. Maybe
-     * we don't need 'set debug-file-directory ...' at all?
-     */
-    args[2] = (char*)"-ex";
-    args[3] = (char*)"set debug-file-directory /usr/lib/debug";
-
-    /* "file BINARY_FILE" is needed, without it gdb cannot properly
-     * unwind the stack. Currently the unwind information is located
-     * in .eh_frame which is stored only in binary, not in coredump
-     * or debuginfo.
-     *
-     * Fedora GDB does not strictly need it, it will find the binary
-     * by its build-id.  But for binaries either without build-id
-     * (= built on non-Fedora GCC) or which do not have
-     * their debuginfo rpm installed gdb would not find BINARY_FILE
-     * so it is still makes sense to supply "file BINARY_FILE".
-     *
-     * Unfortunately, "file BINARY_FILE" doesn't work well if BINARY_FILE
-     * was deleted (as often happens during system updates):
-     * gdb uses specified BINARY_FILE
-     * even if it is completely unrelated to the coredump.
-     * See https://bugzilla.redhat.com/show_bug.cgi?id=525721
-     *
-     * TODO: check mtimes on COREFILE and BINARY_FILE and not supply
-     * BINARY_FILE if it is newer (to at least avoid gdb complaining).
-     */
-    args[4] = (char*)"-ex";
-    args[5] = xasprintf("file %s", executable);
-    free(executable);
-
-    args[6] = (char*)"-ex";
-    args[7] = xasprintf("core-file %s/"FILENAME_COREDUMP, dump_dir_name);
-
-    args[8] = (char*)"-ex";
-    /*args[9] = ... see below */
-    args[10] = NULL;
-
-    /* Get the backtrace, but try to cap its size */
-    /* Limit bt depth. With no limit, gdb sometimes OOMs the machine */
-    unsigned bt_depth = 2048;
-    char *bt = NULL;
-    while (1)
-    {
-        args[9] = xasprintf("backtrace %u", bt_depth);
-        bt = exec_vp(args, uid, /*redirect_stderr:*/ 1, /*exec_timeout_sec:*/ 240, NULL);
-        free(args[9]);
-        if ((bt && strnlen(bt, 256*1024) < 256*1024) || bt_depth <= 32)
-        {
-            break;
-        }
-
-        free(bt);
-        bt_depth /= 2;
-    }
-
-    free(args[5]);
-    free(args[7]);
-    return bt;
-}
-
-#ifdef ENABLE_DISASSEMBLY
-/* Read len bytes and interpret them as a number. Pointer p does not have to be
- * aligned.
- * XXX Assumption: we'll always run on architecture the ELF is run on,
- * therefore we don't consider byte order.
- */
-static uintptr_t fde_read_address(const uint8_t *p, unsigned len)
-{
-    int i;
-    union {
-        uint8_t b[8];
-        /* uint16_t n2; */
-        uint32_t n4;
-        uint64_t n8;
-    } u;
-
-    for (i = 0; i < len; i++)
-    {
-        u.b[i] = *p++;
-    }
-
-    return (len == 4 ? (uintptr_t)u.n4 : (uintptr_t)u.n8);
-}
-
-/* Given DWARF pointer encoding, return the length of the pointer in bytes.
- */
-static unsigned encoded_size(const uint8_t encoding, const unsigned char *e_ident)
-{
-    switch (encoding & 0x07)
-    {
-        case DW_EH_PE_udata2:
-            return 2;
-        case DW_EH_PE_udata4:
-            return 4;
-        case DW_EH_PE_udata8:
-            return 8;
-        case DW_EH_PE_absptr:
-            return (e_ident[EI_CLASS] == ELFCLASS32 ? 4 : 8);
-        default:
-            return 0; /* Don't know/care. */
-    }
-}
-
-static void log_elf_error(const char *function, const char *filename)
-{
-    log("%s failed for %s: %s", function, filename, elf_errmsg(-1));
-}
-
-/* TODO: sensible types */
-/* Load ELF 'filename', parse the .eh_frame contents, and for each entry in the
- * second argument check whether its address is contained in the range of some
- * Frame Description Entry. If it does, fill in the function range of the
- * entry. In other words, try to assign start address and length of function
- * corresponding to each backtrace entry. We'll need that for the disassembly.
- *
- * Fails quietly - we should still be able to use the build ids.
- *
- * I wonder if this is really better than parsing eu-readelf text output.
- */
-static void elf_iterate_fdes(const char *filename, GList *entries)
-{
-    int fd;
-    Elf *e;
-    const unsigned char *e_ident;
-    const char *scnname;
-    Elf_Scn *scn;
-    Elf_Data *scn_data;
-    GElf_Shdr shdr;
-    GElf_Phdr phdr;
-    size_t shstrndx, phnum;
-
-    /* Initialize libelf, open the file and get its Elf handle. */
-    if (elf_version(EV_CURRENT) == EV_NONE)
-    {
-        VERB1 log_elf_error("elf_version", filename);
-        return;
-    }
-
-    fd = xopen(filename, O_RDONLY);
-
-    e = elf_begin(fd, ELF_C_READ, NULL);
-    if (e == NULL)
-    {
-        VERB1 log_elf_error("elf_begin", filename);
-        goto ret_close;
-    }
-
-    e_ident = (unsigned char *)elf_getident(e, NULL);
-    if (e_ident == NULL)
-    {
-        VERB1 log_elf_error("elf_getident", filename);
-        goto ret_elf;
-    }
-
-    /* Look up the .eh_frame section */
-    if (elf_getshdrstrndx(e, &shstrndx) != 0)
-    {
-        VERB1 log_elf_error("elf_getshdrstrndx", filename);
-        goto ret_elf;
-    }
-
-    scn = NULL;
-    while ((scn = elf_nextscn(e, scn)) != NULL)
-    {
-        if (gelf_getshdr(scn, &shdr) != &shdr)
-        {
-            VERB1 log_elf_error("gelf_getshdr", filename);
-            continue;
-        }
-
-        scnname = elf_strptr(e, shstrndx, shdr.sh_name);
-        if (scnname == NULL)
-        {
-            VERB1 log_elf_error("elf_strptr", filename);
-            continue;
-        }
+#include <satyr/abrt.h>
+#include <satyr/utils.h>
 
-        if (strcmp(scnname, ".eh_frame") == 0)
-        {
-            break; /* Found. */
-        }
-    }
-
-    if (scn == NULL)
-    {
-        VERB1 log("Section .eh_frame not found in %s", filename);
-        goto ret_elf;
-    }
-
-    scn_data = elf_getdata(scn, NULL);
-    if (scn_data == NULL)
-    {
-        VERB1 log_elf_error("elf_getdata", filename);
-        goto ret_elf;
-    }
-
-    /* Get the address at which the executable segment is loaded. If the
-     * .eh_frame addresses are absolute, this is used to convert them to
-     * relative to the beginning of executable segment. We are looking for the
-     * first LOAD segment that is executable, I hope this is sufficient.
-     */
-    if (elf_getphdrnum(e, &phnum) != 0)
-    {
-        VERB1 log_elf_error("elf_getphdrnum", filename);
-        goto ret_elf;
-    }
-
-    uintptr_t exec_base;
-    int i;
-    for (i = 0; i < phnum; i++)
-    {
-        if (gelf_getphdr(e, i, &phdr) != &phdr)
-        {
-            VERB1 log_elf_error("gelf_getphdr", filename);
-            goto ret_elf;
-        }
-
-        if (phdr.p_type == PT_LOAD && phdr.p_flags & PF_X)
-        {
-            exec_base = (uintptr_t)phdr.p_vaddr;
-            goto base_found;
-        }
-    }
-
-    VERB1 log("Can't determine executable base for '%s'", filename);
-    goto ret_elf;
-
-base_found:
-    VERB2 log("Executable base: %jx", (uintmax_t)exec_base);
-
-    /* We now have a handle to .eh_frame data. We'll use dwarf_next_cfi to
-     * iterate through all FDEs looking for those matching the addresses we
-     * have.
-     * Some info on .eh_frame can be found at http://www.airs.com/blog/archives/460
-     * and in DWARF documentation for .debug_frame. The initial_location and
-     * address_range decoding is 'inspired' by elfutils source.
-     * XXX: If this linear scan is too slow, we can do binary search on
-     * .eh_frame_hdr -- see http://www.airs.com/blog/archives/462
-     */
-    int ret;
-    Dwarf_Off cfi_offset;
-    Dwarf_Off cfi_offset_next = 0;
-    Dwarf_CFI_Entry cfi;
-
-    struct cie_encoding {
-        Dwarf_Off cie_offset;
-        int ptr_len;
-        bool pcrel;
-    } *cie;
-    GList *cie_list = NULL;
-
-    while(1)
-    {
-        cfi_offset = cfi_offset_next;
-        ret = dwarf_next_cfi(e_ident, scn_data, 1, cfi_offset, &cfi_offset_next, &cfi);
-
-        if (ret > 0)
-        {
-            /* We're at the end. */
-            break;
-        }
-
-        if (ret < 0)
-        {
-            /* Error. If cfi_offset_next was updated, we may skip the
-             * errorneous cfi. */
-            if (cfi_offset_next > cfi_offset)
-            {
-                continue;
-            }
-            VERB1 log("dwarf_next_cfi failed for %s: %s", filename, dwarf_errmsg(-1));
-            goto ret_list;
-        }
-
-        if (dwarf_cfi_cie_p(&cfi))
-        {
-            /* Current CFI is a CIE. We store its offset and FDE encoding
-             * attributes to be used when reading FDEs.
-             */
-
-            /* Default FDE encoding (i.e. no R in augmentation string) is
-             * DW_EH_PE_absptr.
-             */
-            cie = xzalloc(sizeof(*cie));
-            cie->cie_offset = cfi_offset;
-            cie->ptr_len = encoded_size(DW_EH_PE_absptr, e_ident);
-
-            /* Search the augmentation data for FDE pointer encoding.
-             * Unfortunately, 'P' can come before 'R' (which we are looking
-             * for), so we may have to parse the whole thing. See the
-             * abovementioned blog post for details.
-             */
-            const char *aug = cfi.cie.augmentation;
-            const uint8_t *augdata = cfi.cie.augmentation_data;
-            bool skip_cie = 0;
-            if (*aug == 'z')
-            {
-                aug++;
-            }
-            while (*aug != '\0')
-            {
-                if(*aug == 'R')
-                {
-                    cie->ptr_len = encoded_size(*augdata, e_ident);
-
-                    if (cie->ptr_len != 4 && cie->ptr_len != 8)
-                    {
-                        VERB1 log("Unknown FDE encoding (CIE %jx) in %s",
-                                (uintmax_t)cfi_offset, filename);
-                        skip_cie = 1;
-                    }
-                    if ((*augdata & 0x70) == DW_EH_PE_pcrel)
-                    {
-                        cie->pcrel = 1;
-                    }
-                    break;
-                }
-                else if (*aug == 'L')
-                {
-                    augdata++;
-                }
-                else if (*aug == 'P')
-                {
-                    unsigned size = encoded_size(*augdata, e_ident);
-                    if (size == 0)
-                    {
-                        VERB1 log("Unknown size for personality encoding in %s",
-                                filename);
-                        skip_cie = 1;
-                        break;
-                    }
-                    augdata += (size + 1);
-                }
-                else
-                {
-                    VERB1 log("Unknown augmentation char in %s", filename);
-                    skip_cie = 1;
-                    break;
-                }
-                aug++;
-            }
-            if (skip_cie)
-            {
-                free(cie);
-                continue;
-            }
-
-            cie_list = g_list_append(cie_list, cie);
-        }
-        else
-        {
-            /* Current CFI is an FDE.
-             */
-            GList *it = cie_list;
-            cie = NULL;
-
-            /* Find the CIE data that we should have saved earlier. XXX: We can
-             * use hash table/tree to speed up the search, the number of CIEs
-             * should usally be very low though. */
-            while (it != NULL)
-            {
-                cie = it->data;
-
-                /* In .eh_frame, CIE_pointer is relative, but libdw converts it
-                 * to absolute offset. */
-                if(cfi.fde.CIE_pointer == cie->cie_offset)
-                {
-                    break; /* Found. */
-                }
-
-                it = g_list_next(it);
-            }
-
-            if (it == NULL)
-            {
-                VERB1 log("CIE not found for FDE %jx in %s",
-                        (uintmax_t)cfi_offset, filename);
-                continue;
-            }
-
-            /* Read the two numbers we need and if they are PC-relative,
-             * compute the offset from VMA base
-             */
-
-            uintptr_t initial_location = fde_read_address(cfi.fde.start, cie->ptr_len);
-            uintptr_t address_range = fde_read_address(cfi.fde.start+cie->ptr_len, cie->ptr_len);
-
-            if (cie->pcrel)
-            {
-                /* We need to determine how long is the 'length' (and
-                 * consequently CIE id) field of this FDE -- it can be either 4
-                 * or 12 bytes long. */
-                uintptr_t length = fde_read_address(scn_data->d_buf + cfi_offset, 4);
-                uintptr_t skip = (length == 0xffffffffUL ? 12 : 4);
-
-                uintptr_t mask = (cie->ptr_len == 4 ? 0xffffffffUL : 0xffffffffffffffffUL);
-                initial_location += (uintptr_t)shdr.sh_offset + (uintptr_t)cfi_offset + 2*skip;
-                initial_location &= mask;
-            }
-            else
-            {
-                /* Assuming that not pcrel means absolute address (what if the file is a library?).
-                 * Convert to text-section-start-relative.
-                 */
-                initial_location -= exec_base;
-            }
-
-            /* Iterate through the backtrace entries and check each address
-             * member whether it belongs into the range given by current FDE.
-             */
-            for (it = entries; it != NULL; it = g_list_next(it))
-            {
-                struct backtrace_entry *entry = it->data;
-                if (initial_location <= entry->build_id_offset
-                        && entry->build_id_offset < initial_location + address_range)
-                {
-                    /* Convert to before-relocation absolute addresses, disassembler uses those. */
-                    entry->function_initial_loc = exec_base + initial_location;
-                    entry->function_length = address_range;
-                    /*TODO: remove the entry from the list to save a bit of time in next iteration?*/
-                }
-            }
-        }
-    }
-
-ret_list:
-    list_free_with_free(cie_list);
-ret_elf:
-    elf_end(e);
-ret_close:
-    close(fd);
-}
-
-static char* fingerprint_insns(GList *insns)
-{
-    return xasprintf("number_of_instructions:%d", g_list_length(insns));
-}
-
-/* Capture disassembler output into a strbuf.
- * XXX: This may be slow due to lots of reallocations, so if it's a problem,
- * we can replace strbuf with a fixed-size buffer.
- */
-static int buffer_printf(void *buffer, const char *fmt, ...)
-{
-    struct strbuf *strbuf = buffer;
-    va_list p;
-    int orig_len = strbuf->len;
-
-    va_start(p, fmt);
-    buffer = strbuf_append_strfv(buffer, fmt, p);
-    va_end(p);
-
-    return (strbuf->len - orig_len);
-}
-
-static void log_bfd_error(const char *function, const char *filename)
-{
-    log("%s failed for %s: %s", function, filename, bfd_errmsg(bfd_get_error()));
-}
-
-/* Open filename, initialize binutils/libopcodes disassembler, disassemble each
- * function in 'entries' given by the ranges computed earlier and compute
- * fingerprint based on the disassembly.
- */
-static void disassemble_file(const char *filename, GList *entries)
-{
-    bfd *bfdFile;
-    asection *section;
-    disassembler_ftype disassemble;
-    struct disassemble_info info;
-    uintptr_t count, pc;
-    GList *it, *insns;
-    struct backtrace_entry *entry;
-
-    static bool initialized = false;
-    if (!initialized)
-    {
-        bfd_init();
-        initialized = true;
-    }
-
-    bfdFile = bfd_openr(filename, NULL);
-    if (bfdFile == NULL)
-    {
-        VERB1 log_bfd_error("bfd_openr", filename);
-        return;
-    }
-
-    if (!bfd_check_format(bfdFile, bfd_object))
-    {
-        VERB1 log_bfd_error("bfd_check_format", filename);
-        goto ret_close;
-    }
-
-    section = bfd_get_section_by_name(bfdFile, ".text");
-    if (section == NULL)
-    {
-        VERB1 log_bfd_error("bfd_get_section_by_name", filename);
-        goto ret_close;
-    }
-
-    disassemble = disassembler(bfdFile);
-    if (disassemble == NULL)
-    {
-        VERB1 log("Unable to find disassembler");
-        goto ret_close;
-    }
-
-    init_disassemble_info(&info, NULL, buffer_printf);
-    info.arch = bfd_get_arch(bfdFile);
-    info.mach = bfd_get_mach(bfdFile);
-    info.buffer_vma = section->vma;
-    info.buffer_length = section->size;
-    info.section = section;
-    /*TODO: memory error func*/
-    bfd_malloc_and_get_section(bfdFile, section, &info.buffer);
-    disassemble_init_for_target(&info);
-
-    /* Iterate over backtrace entries, disassembly and fingerprint each one. */
-    for (it = entries; it != NULL; it = g_list_next(it))
-    {
-        entry = it->data;
-        uintptr_t function_begin = entry->function_initial_loc;
-        uintptr_t function_end = function_begin + entry->function_length;
-
-        /* Check whether the address range is sane. */
-        if (!(section->vma <= function_begin
-             && function_end <= section->vma + section->size
-             && function_begin < function_end))
-        {
-            VERB2 log("Function range 0x%jx-0x%jx probably wrong", (uintmax_t)function_begin,
-                    (uintmax_t)function_end);
-            continue;
-        }
-
-        /* Iterate over each instruction and add its string representation to a list. */
-        insns = NULL;
-        pc = count = function_begin;
-        while (count > 0 && pc < function_end)
-        {
-            info.stream = strbuf_new();
-            count = disassemble(pc, &info);
-            pc += count;
-            insns = g_list_append(insns, strbuf_free_nobuf(info.stream));
-        }
-
-        /* Compute the actual fingerprint from the list. */
-        /* TODO: Check for failures. */
-        entry->fingerprint = fingerprint_insns(insns);
-
-        list_free_with_free(insns);
-    }
-
-ret_close:
-    bfd_close(bfdFile);
-}
-
-static gint filename_cmp(const struct backtrace_entry *entry, const char *filename)
-{
-    return (entry->filename ? strcmp(filename, entry->filename) : 1);
-}
-
-static void disassemble_and_fingerprint(GList *backtrace)
-{
-    GList *to_be_done = g_list_copy(backtrace);
-    GList *worklist, *it;
-    const char *filename;
-    struct backtrace_entry *entry;
-
-    /* Process each element
-     * We need to divide the backtrace to smaller lists such that each list has
-     * entries associated to the same file name. */
-    while (to_be_done != NULL)
-    {
-        /* Take first entry */
-        entry = to_be_done->data;
-        filename = entry->filename;
-        worklist = NULL;
-
-        /* Skip entries without file names */
-        if (filename == NULL || strcmp(filename, "-") == 0)
-        {
-            to_be_done = g_list_remove(to_be_done, entry);
-            continue;
-        }
-
-        /* Find entries with the same filename */
-        while ((it = g_list_find_custom(to_be_done, filename, (GCompareFunc)filename_cmp)) != NULL)
-        {
-            entry = it->data;
-
-            /* Add it to the worklist */
-            worklist = g_list_append(worklist, entry);
-
-            /* Remove it from the list of remaining elements */
-            to_be_done = g_list_remove(to_be_done, entry);
-        }
-
-        /* This should never happen, but if it does, we end up in an infinite loop. */
-        if (worklist == NULL)
-        {
-            VERB1 log("%s internal error", __func__);
-            return;
-        }
-
-        /* Process the worklist */
-        VERB2 log("Extracting function ranges from %s", filename);
-        elf_iterate_fdes(filename, worklist);
-
-        VERB2 log("Disassembling functions from %s", filename);
-        disassemble_file(filename, worklist);
-    }
-}
-#endif /* ENABLE_DISASSEMBLY */
+#include "libabrt.h"
 
 int main(int argc, char **argv)
 {
@@ -885,16 +33,18 @@ int main(int argc, char **argv)
     abrt_init(argv);
 
     const char *dump_dir_name = ".";
+    int raw_fingerprints = 0; /* must be _int_, OPT_BOOL expects that! */
 
     /* Can't keep these strings/structs static: _() doesn't support that */
     const char *program_usage_string = _(
-        "& [-v] -d DIR\n"
+        "& [-v] [-r] -d DIR\n"
         "\n"
         "Creates coredump-level backtrace from core dump and corresponding binary"
     );
     enum {
         OPT_v = 1 << 0,
         OPT_d = 1 << 1,
+        OPT_r = 1 << 2,
     };
     /* Keep enum above and order of options below in sync! */
     struct options program_options[] = {
@@ -906,35 +56,45 @@ int main(int argc, char **argv)
 
     export_abrt_envvars(0);
 
+    if (g_verbose > 1)
+        sr_debug_parser = true;
 
-    VERB1 log("Querying gdb for backtrace");
-    char *gdb_out = get_gdb_output(dump_dir_name);
-    if (gdb_out == NULL)
-        return 1;
+    /* Let user know what's going on */
+    log(_("Generating core_backtrace"));
+
+    char *error_message = NULL;
+    bool success;
+
+#ifdef ENABLE_NATIVE_UNWINDER
 
-    /* parse addresses and eventual symbols from the output*/
-    GList *backtrace = extract_addresses(gdb_out);
-    VERB1 log("Extracted %d frames from the backtrace", g_list_length(backtrace));
-    free(gdb_out);
+    success = sr_abrt_create_core_stacktrace(dump_dir_name, !raw_fingerprints,
+                                             &error_message);
+#else /* ENABLE_NATIVE_UNWINDER */
 
-    /* eu-unstrip - build ids and library paths*/
-    VERB1 log("Running eu-unstrip -n to obtain build ids");
-    assign_build_ids(backtrace, dump_dir_name);
+    /* The value 240 was taken from abrt-action-generate-backtrace.c. */
+    int exec_timeout_sec = 240;
 
-#ifdef ENABLE_DISASSEMBLY
-    /* Extract address ranges from all the executables in the backtrace*/
-    VERB1 log("Computing function fingerprints");
-    disassemble_and_fingerprint(backtrace);
-#endif /* ENABLE_DISASSEMBLY */
+    char *gdb_output = get_backtrace(dump_dir_name, exec_timeout_sec, NULL);
+    if (!gdb_output)
+    {
+        log(_("Error: GDB did not return any data"));
+        return 1;
+    }
 
-    char *formated_backtrace = backtrace_format(backtrace);
+    success = sr_abrt_create_core_stacktrace_from_gdb(dump_dir_name,
+                                                      gdb_output,
+                                                      !raw_fingerprints,
+                                                      &error_message);
+    free(gdb_output);
 
-    struct dump_dir *dd = dd_opendir(dump_dir_name, /*flags:*/ 0);
-    if (!dd)
+#endif /* ENABLE_NATIVE_UNWINDER */
+
+    if (!success)
+    {
+        log(_("Error: %s"), error_message);
+        free(error_message);
         return 1;
-    dd_save_text(dd, FILENAME_CORE_BACKTRACE, formated_backtrace);
-    dd_close(dd);
+    }
 
-    free(formated_backtrace);
     return 0;
 }
diff --git a/src/plugins/ccpp_event.conf b/src/plugins/ccpp_event.conf
index fff903b..dfb92a3 100644
--- a/src/plugins/ccpp_event.conf
+++ b/src/plugins/ccpp_event.conf
@@ -3,7 +3,7 @@ EVENT=post-create analyzer=CCpp
         # try generating backtrace, if it fails we can still use
         # the UUID generated by abrt-action-analyze-c:
         #(disabled for RHEL - it needs gdb, which isn't always installed)
-        #abrt-action-generate-core-backtrace
+        abrt-action-generate-core-backtrace
         abrt-action-analyze-c &&
         abrt-action-list-dsos -m maps -o dso_list &&
         (
-- 
1.8.3.1

